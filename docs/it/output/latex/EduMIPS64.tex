% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{EduMIPS64 Documentation}
\date{September 19, 2011}
\release{0.5.3}
\author{Andrea Spadaccini ed il team di sviluppo di EduMIPS64\\(traduzione italiana di Simona Ullo)}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


EduMIPS64 è un simulatore di Instruction Set Architecture (ISA) MIPS64,
progettato per eseguire piccoli programmi che utilizzino il sottoinsieme
dell'Instruction Set MIPS64 implementato dal simulatore stesso; permette
all'utente di vedere come le istruzioni si comportino nella pipeline, come gli
stalli siano gestiti dalla CPU, lo stato di registri e memoria e molto altro.
È classificabile sia come simulatore, sia come debugger visuale.

EduMIPS64 è stato progettato e sviluppato da un gruppo di studenti
dell'Università degli Studi di Catania, ed ha tratto spunto, come interfaccia
e come funzionamento, dal simulatore WinMIPS64, sebbene vi siano alcune
differenze importanti con quest'ultimo.

Questo manuale vi introdurrà ad EduMIPS64, e spiegherà come utilizzarlo.

Il primo capitolo del manuale riguarda il formato dei file sorgente accettato
dal simulatore, descrivendo i tipi di dato e le direttive, oltre ai parametri da
linea di comando.

Nel secondo capitolo è presentata una panoramica del set di istruzioni
MIPS64 utilizzato da EduMIPS64, con tutti i parametri richiesti e le indicazioni per
il loro utilizzo.

Il terzo capitolo è una descrizione dell'interfaccia utente di EduMIPS64, che
espone lo scopo di ciascuna finestra e di ciascun menù, insieme ad una
descrizione delle finestre di configurazione, del Dinero frontend, del manuale e
delle opzioni da linea di comando.

Il quarto capitolo contiene alcune esempi pratici di utilizzo del simulatore.

Questo manuale si riferisce ad EduMIPS64 versione 0.5.3.


\chapter{Formato dei file sorgenti}
\label{source-files-format:benvenuti-nella-documentazione-di-edumips64}\label{source-files-format:formato-dei-file-sorgenti}\label{source-files-format::doc}
EduMIPS64 si propone di seguire le convenzioni usate negli altri simulatori
MIPS64 e DLX, in modo tale da non creare confusione riguardante la sintassi
per i vecchi utenti.

All'interno di un file sorgente sono presenti due sezioni: quella dedicata ai
\emph{dati} e quella in cui è contenuto il \emph{codice}, introdotte rispettivamente
dalle direttive \emph{.data} e \emph{.code}. Nel seguente listato è possibile vedere un
semplice programma:

\begin{Verbatim}[commandchars=@\[\]]
; Questo è un commento
          .data
  label:  .word   15     ; Questo è un commento in linea

          .code
          daddi   r1, r0, 0
          syscall 0
\end{Verbatim}

Per distinguere le varie parti di ciascuna linea di codice, può essere
utilizzata una qualunque combinazione di spazi e tabulazioni, visto che il
parser ignora spazi multipli.

I commenti possono essere introdotti utilizzando il carattere '';'' qualsiasi
cosa venga scritta successivamente ad esso verrà ignorata.  Un commento
può quindi essere usato ``inline'' (dopo una direttiva) oppure in una riga a
sè stante.

Le etichette possono essere usate nel codice per fare riferimento ad una cella
di memoria o ad un'istruzione.  Esse sono case insensitive. Per ciascuna linea
di codice può essere utilizzata un'unica etichetta. Quest'ultima può essere
inserita una o più righe al di sopra dell'effettiva dichiarazione del dato
o dell'istruzione, facendo in modo che non ci sia nulla, eccetto commenti e
linee vuote, tra l'etichetta stessa e la dichiarazione.


\section{La sezione \emph{.data}}
\label{source-files-format:la-sezione-data}
La sezione \emph{data} contiene i comandi che specificano il modo in cui la
memoria deve essere riempita prima dell'inizio dell'esecuzione del programma. La
forma generale di un comando \emph{.data} è:

\begin{Verbatim}[commandchars=@\[\]]
@PYGZlb[]etichetta:@PYGZrb[] .tipo-dato valore1 @PYGZlb[], valore2 @PYGZlb[], ...@PYGZrb[]@PYGZrb[]
\end{Verbatim}

EduMIPS64 supporta diversi tipi di dato, che sono descritti nella seguente
tabella.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Tipo
} & \textbf{
Direttiva
} & \textbf{
Bit richiesti
}\\
\hline

Byte
 & 
\emph{.byte}
 & 
8
\\

Half word
 & 
\emph{.word16}
 & 
16
\\

Word
 & 
\emph{.word32}
 & 
32
\\

Double Word
 & 
\emph{.word} or \emph{.word64}
 & 
64
\\
\hline
\end{tabulary}

\end{quote}

Dati di tipo doubleword possono essere introdotti sia dalla direttiva
\emph{.word} che dalla direttiva \emph{.word64}.

Esiste una differenza sostanziale tra la dichiarazione di una lista di dati
utilizzando un'unica direttiva oppure direttive multiple dello stesso tipo.
EduMIPS64 inizia la scrittura a partire dalla successiva double word a 64 bit non appena
trova un identificatore del tipo di dato, in tal modo la prima istruzione \emph{.byte}
del seguente listato inserirà i numeri 1, 2, 3 e 4 nello spazio di 4 byte,
occupando 32 bit, mentre il codice delle successive quattro righe inserirà ciascun numero
in una differente cella di memoria, occupando 32 byte:

\begin{Verbatim}[commandchars=@\[\]]
.data
.byte    1, 2, 3, 4
.byte    1
.byte    2
.byte    3
.byte    4
\end{Verbatim}

Nella seguente tabella, la memoria è rappresentata utilizzando celle di dimensione pari
ad 1 byte e ciascuna riga è lunga 64 bit. L'indirizzo posto alla sinistra di ogni riga della tabella è
riferito alla cella di memoria più a destra, che possiede l'indirizzo più basso rispetto alle otto celle in ciascuna linea.

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|}
\hline

\emph{0}
 & 
0
 & 
0
 & 
0
 & 
0
 & 
4
 & 
3
 & 
2
 & 
1
\\

\emph{8}
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
1
\\

\emph{16}
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
2
\\

\emph{24}
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
3
\\

\emph{36}
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
0
 & 
4
\\
\hline
\end{tabulary}


Ci sono alcune direttive speciali che devono essere discusse: \emph{.space},
\emph{.ascii} e \emph{.asciiz}.

La direttiva \emph{.space} è usata per lasciare dello spazio vuoto in memoria.
Essa accetta un intero come parametro, che indica il numero di byte che devono
essere lasciati liberi.  Tale direttiva è utile quando è necessario conservare
dello spazio in memoria per i risultati dei propri calcoli.

La direttiva \emph{.ascii} accetta stringhe contenenti un qualunque carattere
ASCII, ed alcune ``sequenze di escape'', simili a quelle presenti nel linguaggio
C, che sono descritte nella seguente tabella, ed inserisce tali stringhe in
memoria.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Sequenza di escape
} & \textbf{
Significato
} & \textbf{
Codice ASCII
}\\
\hline

\textbackslash{}0
 & 
Byte nullo
 & 
0
\\

\textbackslash{}t
 & 
Tabulazione orizzontale
 & 
9
\\

\textbackslash{}n
 & 
Carattere di inizio nuova linea
 & 
10
\\

\textbackslash{}''
 & 
Doppi apici
 & 
34
\\
 & 
Backslash
 & 
92
\\
\hline
\end{tabulary}

\end{quote}

La direttiva \emph{.asciiz} si comporta esattamente come il comando \emph{.ascii}, con
la differenza che essa pone automaticamente alla fine della stringa un byte
nullo.


\section{La sezione \emph{.code}}
\label{source-files-format:la-sezione-code}
La sezione \emph{code} contiene le istruzioni che saranno eseguite dal
simulatore a run-time. La forma generale di un comando \emph{.code} è:

\begin{Verbatim}[commandchars=@\[\]]
@PYGZlb[]etichetta:@PYGZrb[] istruzione @PYGZlb[]param1 @PYGZlb[], param2 @PYGZlb[], param3@PYGZrb[]@PYGZrb[]@PYGZrb[]
\end{Verbatim}

Essa può essere indicata anche con la direttiva \emph{.text}.

Il numero e il tipo di parametri dipendono dall'istruzione stessa.

Le istruzioni possono accettare tre tipi di parametri:
\begin{itemize}
\item {} 
\emph{Registri} un parametro di tipo registro è indicato da una
``r'' maiuscola o minuscola, o da un carattere ``\$'', a fianco del numero
di registro (tra 0 e 31). Ad esempio, le scritture ``r4'', ``R4'' e ``\$4''
identificano tutt'e tre il quarto registro;

\item {} 
\emph{Valori immediati} un valore immediato pu{}`o essere un numero o
un'etichetta; il numero può essere specificato in base 10 o in base 16. I
numeri in base 10 sono inseriti semplicemente scrivendo il numero
utilizzando l'usuale notazione decimale; i numeri in base 16 si inseriscono
aggiungendo all'inizio del numero il prefisso ``0x'';

\item {} 
\emph{Indirizzi} un indirizzo è composto da un valore immediato
seguito dal nome di un registro tra parentesi. Il valore del registro sarà
usato come base, quello dell'immediato come offset.

\end{itemize}

La dimensione dei valori immediati è limitata al numero di bit disponibili
nella codifica associata all'istruzione.

è possibile utilizzare gli alias standard MIPS per i primi 32 registri,
mettendo in coda ai prefissi standard per i registri (``r'', ``\$'', ``R'') uno
degli alias indicati nella seguente tabella.
\begin{quote}

\begin{longtable}{|l|l|}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot

\textbf{
Registro
} & \textbf{
Alias
}\\
\hline

0
 & 
\emph{zero}
\\

1
 & 
\emph{at}
\\

2
 & 
\emph{v0}
\\

3
 & 
\emph{v1}
\\

4
 & 
\emph{a0}
\\

5
 & 
\emph{a1}
\\

6
 & 
\emph{a2}
\\

7
 & 
\emph{a3}
\\

8
 & 
\emph{t0}
\\

9
 & 
\emph{t1}
\\

10
 & 
\emph{t2}
\\

11
 & 
\emph{t3}
\\

12
 & 
\emph{t4}
\\

13
 & 
\emph{t5}
\\

14
 & 
\emph{t6}
\\

15
 & 
\emph{t7}
\\

16
 & 
\emph{s0}
\\

17
 & 
\emph{s1}
\\

18
 & 
\emph{s2}
\\

19
 & 
\emph{s3}
\\

20
 & 
\emph{s4}
\\

21
 & 
\emph{s5}
\\

22
 & 
\emph{s6}
\\

23
 & 
\emph{s7}
\\

24
 & 
\emph{t8}
\\

25
 & 
\emph{t9}
\\

26
 & 
\emph{k0}
\\

27
 & 
\emph{k1}
\\

28
 & 
\emph{gp}
\\

29
 & 
\emph{sp}
\\

30
 & 
\emph{fp}
\\

31
 & 
\emph{ra}
\\
\hline
\end{longtable}

\end{quote}


\section{Il comando \emph{\#include}}
\label{source-files-format:il-comando-include}
Nei sorgenti può essere utilizzato il comando \emph{*\#include* nomefile}, che ha
l'effetto di inserire, al posto della riga contenente questo comando, il
contenuto del file \emph{nomefile}.
Questo comando è utile se si vogliono includere delle funzioni esterne, ed è
dotato di un algoritmo di rilevamento dei cicli, che impedisce di eseguire
inclusioni circolari tipo ``\emph{\#include A.s}'' nel file \emph{B.s} e
``\emph{\#include B.s}'' nel file \emph{A.s}.


\chapter{Il set di istruzioni}
\label{instructions::doc}\label{instructions:il-set-di-istruzioni}
In questa sezione verrà illustrato il repertorio delle istruzioni MIPS64
riconosciute da EduMIPS64. è possibile effettuare due differenti
classificazioni: una basata sulla funzionalità delle istruzioni e l'altra
basata sul tipo di parametri.

La prima classificazione suddivide le istruzioni in tre categorie: istruzioni
ALU, istruzioni Load/Store, istruzioni di controllo del flusso. I prossimi tre
paragrafi descriveranno ciascuna categoria e le istruzioni che vi
appartengono.

Il quarto paragrafo descriverà le istruzioni che non rientrano in nessuna
delle tre categorie sopraelencate.


\section{Le istruzioni ALU}
\label{instructions:le-istruzioni-alu}
L'unità logico-aritmetica (ALU) fa parte dell'unità esecutiva di una
CPU ed assume il ruolo di esecuzione di operazioni logiche ed aritmetiche. Il
gruppo di istruzioni ALU conterrà quindi quelle istruzioni che effettuano
questo tipo di operazioni.

Le istruzioni ALU possono essere suddivise in due gruppi: \emph{tipo R} e
\emph{tipo I}.

Quattro di esse utilizzano due registri speciali: LO e HI. Tali registri sono
interni alla CPU ed è possibile accedere al loro valore mediante le
istruzioni \emph{MFLO} e \emph{MFHI}.

Ecco la lista delle istruzioni ALU di tipo R.
\begin{itemize}
\item {} 
\emph{AND rd, rs, rt}

Esegue un AND bit a bit tra rs ed rt, e pone il risultato in rd.

\item {} 
\emph{ADD rd, rs, rt}

Somma il contenuto dei registri a 32-bit rs ed rt, considerandoli come
valori con segno, e pone il risultato in rd.  Lancia un'eccezione in caso di
overflow.

\item {} 
\emph{ADDU rd, rs, rt}

Somma il contenuto dei registri a 32-bit rs ed rt, e pone il risultato in
rd. Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{DADD rd, rs, rt}

Somma il contenuto dei registri a 64-bit rs ed rt, considerandoli come
valori con segno, e pone il risultato in rd.  Lancia un'eccezione in caso di
overflow.

\item {} 
\emph{DADDU rd, rs, rt}

Somma il contenuto dei registri a 64-bit rs ed rt, e pone il risultato in rd.
Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{DDIV rs, rt}

Esegue la divisione tra i registri a 64-bit rs ed rt, ponendo i 64-bit del
quoziente in LO ed i 64-bit del resto in HI.

\item {} 
\emph{DDIVU rs, rt}

Esegue la divisione tra i registri a 64-bit rs ed rt, considerandoli come
valori senza segno e ponendo i 64-bit del quoziente in LO ed i 64-bit del
resto in HI.

\item {} 
\emph{DIV rs, rt}

Esegue la divisione tra i registri a 32-bit rs ed rt, ponendo i 32-bit del
quoziente in LO ed i 32-bit del resto in HI.

\item {} 
\emph{DIVU rs, rt}

Esegue la divisione tra i registri a 32-bit rs ed rt, considerandoli come
valori senza segno e pone i 32-bit del quoziente in LO ed i 32-bit del resto
in HI.

\item {} 
\emph{DMULT rs, rt}

Esegue il prodotto tra i registri a 64-bit rs ed rt, ponendo i 64 bit bassi
del risultato nel registro speciale LO e i 64 bit alti del risultato nel
registro speciale HI.

\item {} 
\emph{DMULTU rs, rt}

Esegue il prodotto tra i registri a 64-bit rs ed rt, considerandoli come
valori senza segno e ponendo i 64 bit bassi del risultato nel registro
speciale LO e i 64 bit alti del risultato nel registro speciale HI.

\item {} 
\emph{DSLL rd, rt, sa}

Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di
bit indicato nel valore immediato (positivo compreso tra 0 e 63) sa, e pone
il risultato in rd. I bit liberi vengono posti a zero.

\item {} 
\emph{DSLLV rd, rt, rs}

Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di
bit specificato nei 6 bit bassi del registro rs che verrà letto come valore
senza segno, e pone il risultato in rd. I bit liberi vengono posti a zero.

\item {} 
\emph{DSRA rd, rt, sa}

Effettua uno shift verso destra del registro a 64-bit rt, di un numero di
bit specificato nel valore senza segno immediato (positivo compreso tra 0 e
63) sa, e pone il risultato in rd. I bit liberi vengono posti a zero se il
bit più a sinistra di rs è zero, altrimenti vengono posti a uno.

\item {} 
\emph{DSRAV rd, rt, rs}

Effettua uno shift verso destra del registro a 64-bit rt, di un numero di
bit specificato nei 6 bit bassi del registro rs che verrà letto come valore
senza segno,e pone il risultato in rd.  I bit liberi vengono posti a zero se
il bit più a sinistra di rs è zero, altrimenti vengono posti a uno.

\item {} 
\emph{DSRL rd, rs, sa}

Effettua uno shift verso destra del registro a 64-bit rt, di un numero di
bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, e
pone il risultato in rd. I bit liberi vengono posti a zero.

\item {} 
\emph{DSRLV rd, rt, rs}

Effettua uno shift verso destra del registro a 64-bit rt, di un numero di
bit specificato nei 6 bit bassi del registro rs che verrà letto come valore
senza segno, e pone il risultato in rd. I bit liberi vengono posti a zero.

\item {} 
\emph{DSUB rd, rs, rt}

Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit
rs, considerandoli come valori con segno, e pone il risultato in rd. Lancia
un'eccezione in caso di overflow.

\item {} 
\emph{DSUBU rd, rs, rt}

Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit
rs, e pone il risultato in rd.  Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{MFLO rd}

Copia il contenuto del registro speciale LO in rd.

\item {} 
\emph{MFHI rd}

Copia il contenuto del registro speciale HI in rd.

\item {} 
\emph{MOVN rd, rs, rt}

Se rt è diverso da zero, copia il contenuto di rs in rd.

\item {} 
\emph{MOVZ rd, rs, rt}

Se rt è uguale a zero, copia il contenuto di rs in rd.

\item {} 
\emph{MULT rs, rt}

Esegue il prodotto tra i registri a 32-bit rs ed rt, ponendo i 32 bit bassi
del risultato nel registro speciale LO e i 32 bit alti del risultato nel
registro speciale HI.

\item {} 
\emph{MULTU rs, rt}

Esegue il prodotto tra i registri a 32-bit rs ed rt, considerandoli come
valori senza segno e ponendo i 32 bit bassi del risultato nel registro
speciale LO e i 32 bit alti del risultato nel registro speciale HI.

\item {} 
\emph{OR rd, rs, rt}

Esegue un OR bit a bit tra rs ed rt, e pone il risultato in rd.

\item {} 
\emph{SLL rd, rt, sa}

Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di
bit indicati nel valore immediato (positivo compreso tra 0 e 63) sa, e pone
il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

\item {} 
\emph{SLLV rd, rt, rs}

Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di
bit specificato nei 5 bit bassi del registro rs che verrà letto come
valore senza segno, e pone il risultato nel registro a 32-bit rd. I bit
liberi vengono posti a zero.

\item {} 
\emph{SRA rd, rt, sa}

Effettua uno shift verso destra del registro a 32-bit rt, di un numero di
bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, e
pone il risultato nel registro a 32-bit rd.  I bit liberi vengono posti a
zero se il bit più a sinistra di rs è zero, altrimenti vengono posti
a uno.

\item {} 
\emph{SRAV rd, rt, rs}

Effettua uno shift verso destra del registro a 32-bit rt, di un numero di
bit specificato nei 5 bit bassi del registro rs che verrà letto come
valore senza segno, e pone il risultato nel registro a 32-bit in rd.  I bit
liberi vengono posti a zero se il bit più a sinistra di rs è zero,
altrimenti vengono posti a uno.

\item {} 
\emph{SRL rd, rs, sa}

Effettua uno shift verso destra del registro a 32-bit rt, di un numero di
bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, e
pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a
zero.

\item {} 
\emph{SRLV rd, rt, rs}

Effettua uno shift verso destra del registro a 32-bit rt, del numero di bit
specificato nei 5 bit bassi del registro rs che verrà letto come valore
senza segno, e pone il risultato nel registro a 32-bit rd. I bit liberi
vengono posti a zero.

\item {} 
\emph{SUB rd, rs, rt}

Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit
rs, considerandoli come valori con segno, e pone il risultato in rd. Lancia
un'eccezione in caso di overflow.

\item {} 
\emph{SUBU rd, rs, rt}

Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit
rs, e pone il risultato in rd.
Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{SLT rd, rs, rt}

Pone il valore di rd ad 1 se il valore contenuto in rs è minore di
quello contenuto in rt, altrimenti pone rd a 0. Questa istruzione esegue un
confronto con segno.

\item {} 
\emph{SLTU rd, rs, rt}

Pone il valore di rd ad 1 se il valore contenuto in rs è minore di
quello contenuto in rt, altrimenti pone rd a 0. Questa istruzione esegue un
confronto senza segno.

\item {} 
\emph{XOR rd, rs, rt}

Esegue un OR esclusivo (XOR) bit a bit tra rs ed rt, e pone il risultato in
rd.

\end{itemize}

Ecco la lista delle istruzioni ALU di tipo I.
\begin{itemize}
\item {} 
\emph{ADDI rt, rs, immediate}

Effettua la somma tra il registro a 32 bit rs ed il valore immediato,
ponendo il risultato in rt.  Questa istruzione considera gli operandi come
valori con segno.  Lancia un'eccezione in caso di overflow.

\item {} 
\emph{ADDIU rt, rs, immediate}

Effettua la somma tra il registro a 32 bit rs ed il valore immediato,
ponendo il risultato in rt.  Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{ANDI rt, rs, immediate}

Esegue un AND bit a bit tra rs ed il valore immediato, ponendo il risultato
in rt.

\item {} 
\emph{DADDI rt, rs, immediate}

Effettua la somma tra il registro a 64 bit rs ed il valore immediato,
ponendo il risultato in rt.  Questa istruzione considera gli operandi come
valori con segno.  Lancia un'eccezione in caso di overflow.

\item {} 
\emph{DADDIU rt, rs, immediate}

Effettua la somma tra il registro a 64 bit rs ed il valore immediato,
ponendo il risultato in rt.  Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{DADDUI rt, rs, immediate}

Effettua la somma tra il registro a 64 bit rs ed il valore immediato,
ponendo il risultato in rt.  Non si verificano eccezioni di overflow.

\end{itemize}
\begin{itemize}
\item {} 
\emph{LUI rt, immediate}

Carica la costante definita dal valore immediato nella metà superiore dei 32
bit inferiori di rt, effettuando l'estensione del segno sui 32 bit superiori
del registro.

\item {} 
\emph{ORI rt, rs, immediate}

Effettua l'OR bit a bit tra rs ed il valore immediato, ponendo il risultato
in rt.

\item {} 
\emph{SLTI rt, rs, immediate}

Pone il valore di rt ad 1 se il valore di rs è minore di quello
dell'immediato, altrimenti pone rt a 0. Questa operazione effettua un
confronto con segno.

\item {} 
\emph{SLTUI rt, rs, immediate}

Pone il valore di rt ad 1 se il valore di rs è minore di quello
dell'immediato, altrimenti pone rt a 0. Questa operazione effettua un
confronto senza segno.

\item {} 
\emph{XORI rt, rs, immediate}

Effettua l'OR esclusivo bit a bit tra rs ed il valore immediato, ponendo il
risultato in rt.

\end{itemize}


\section{Istruzioni load/store}
\label{instructions:istruzioni-load-store}
Questa categoria contiene tutte le istruzioni che effettuano trasferimenti di
dati tra i registri e la memoria. Ognuna di esse è espressa nella forma:

\begin{Verbatim}[commandchars=@\[\]]
@PYGZlb[]etichetta@PYGZrb[] istruzione rt, offset(base)
\end{Verbatim}

In base all'utilizzo di un'istruzione load oppure store, rt rappresenterà di
volta in volta il registro sorgente o destinazione; offset è un'etichetta o un
valore immediato e base è un registro.  L'indirizzo è ottenuto sommando al
valore del registro{}`base{}` il valore immediato di \emph{offset}.

L'indirizzo specificato deve essere allineato in base al tipo di dato che si
sta trattando.  Le istruzioni di caricamento che terminano con ``U'' considerano
il contenuto del registro rt come un valore senza segno.

Ecco la lista delle istruzioni di caricamento (LOAD):
\begin{itemize}
\item {} 
\emph{LB rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come byte con segno.

\item {} 
\emph{LBU rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come byte senza
segno.

\item {} 
\emph{LD rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come una double
word.

\item {} 
\emph{LH rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come una half word
con segno.

\item {} 
\emph{LHU rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come una half word
senza segno.

\item {} 
\emph{LW rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come una word con
segno.

\item {} 
\emph{LWU rt, offset(base)}

Carica il contenuto della cella di memoria all'indirizzo specificato da
offset e base nel registro rt, considerando tale valore come una word senza
segno.

\end{itemize}

Ecco la lista delle istruzioni di memorizzazione (STORE):
\begin{itemize}
\item {} 
\emph{SB rt, offset(base)}

Memorizza il contenuto del registro rt nella cella di memoria specificata da
offset e base, considerando tale valore come un byte.

\item {} 
\emph{SD rt, offset(base)}

Memorizza il contenuto del registro rt nella cella di memoria specificata da
offset e base, considerando tale valore come una double word.

\item {} 
\emph{SH rt, offset(base)}

Memorizza il contenuto del registro rt nella cella di memoria specificata da
offset e base, considerando tale valore come una half word.

\item {} 
\emph{SW rt, offset(base)}

Memorizza il contenuto del registro rt nella cella di memoria specificata da
offset e base, considerando tale valore come una word.

\end{itemize}


\section{Istruzioni di controllo del flusso}
\label{instructions:istruzioni-di-controllo-del-flusso}
Le istruzioni di controllo del flusso sono utilizzate per alterare l'ordine
delle istruzioni prelevate dalla CPU nella fase di fetch. è possibile fare una
distinzione tra tali istruzioni: tipo R, tipo I e tipo J.

Tali istruzioni eseguono il salto alla fase di Instruction Decode (ID), ogni
qual volta viene effettuato un fetch inutile. In tal caso, due istruzioni
vengono rimosse dalla pipeline, ed il contatore degli stalli dovuti ai salti
effettuati viene incrementato di due unità.

Ecco la lista delle istruzioni di controllo del flusso di tipo R:
\begin{itemize}
\item {} 
\emph{JALR rs}

Pone il contenuto di rs nel program counter, e salva in R31 l'indirizzo
dell'istruzione che segue l'istruzione JALR, che rappresenta il valore di
ritorno.

\item {} 
\emph{JR rs}

Pone il contenuto di rs nel program counter.

\end{itemize}

Ed ecco le istruzioni di controllo del flusso di tipo I:
\begin{itemize}
\item {} 
\emph{B offset}

Salto incondizionato ad offset.

\item {} 
\emph{BEQ rs, rt, offset}

Salta ad offset se rs è uguale ad rt.

\item {} 
\emph{BEQZ rs, offset}

Salta ad offset se rs è uguale a zero.

\end{itemize}
\begin{itemize}
\item {} 
\emph{BGEZ rs, offset}

Effettua un salto relativo al PC ad offset se rs è maggiore di zero.

\item {} 
\emph{BNE rs, rt, offset}

Salta ad offset se rs non è uguale ad rt.

\item {} 
\emph{BNEZ rs}

Salta ad offset se rs non è uguale a zero.

\end{itemize}

Ecco la lista delle istruzioni di controllo del flusso di tipo J:
\begin{itemize}
\item {} 
\emph{J target}

Pone il valore immediato nel program counter

\item {} 
\emph{JAL target}

Pone il valore immediato nel program counter, e salva in R31 l'indirizzo
dell'istruzione che segue l'istruzione JAL, che rappresenta il valore di
ritorno.

\end{itemize}


\section{L'istruzione \emph{SYSCALL}}
\label{instructions:l-istruzione-syscall}
L'istruzione SYSCALL offre al programmatore un'interfaccia simile a quella
offerta da un sistema operativo, rendendo disponibili sei differenti chiamate
di sistema (system call).

Le system call richiedono che l'indirizzo dei loro parametri sia memorizzato
nel registro R14, e pongono il loro valore di ritorno nel registro R1.  Tali
system call sono il più possibile fedeli alla convenzione POSIX.


\subsection{\emph{SYSCALL 0 - exit()}}
\label{instructions:syscall-0-exit}
SYSCALL 0 non richiede alcun parametro nè ritorna nulla, semplicemente ferma
il simulatore.

è opportuno notare che se il simulatore non trova SYSCALL 0 nel codice
sorgente, o una qualsiasi istruzione equivalente (HALT  TRAP 0), terminerà
automaticamente alla fine del sorgente.


\subsection{\emph{SYSCALL 1 - open()}}
\label{instructions:syscall-1-open}
SYSCALL 1 richiede due parametri: una stringa (che termini con valore zero) che
indica il percorso del file che deve essere aperto, ed una double word
contenente un intero che indica i parametri che devono essere usati per
specificare come aprire il file.

Tale intero può essere costruito sommando i parametri che si vogliono
utilizzare, scelti dalla seguente lista:
\begin{itemize}
\item {} 
\emph{O\_RDONLY (0x01)} Apre il file in modalità sola lettura;

\item {} 
\emph{O\_WRONLY (0x02)} Apre il file in modalità sola scrittura;

\item {} 
\emph{O\_RDWR (0x03)} Apre il file in modalità di lettura/scrittura;

\item {} 
\emph{O\_CREAT (0x04)} Crea il file se non esiste;

\item {} 
\emph{O\_APPEND (0x08)} In modalità di scrittura, aggiunge il testo alla fine del file;

\item {} 
\emph{O\_TRUNC (0x08)} In modalità di scrittura, cancella il contenuto del file al momento della sua apertura.

\end{itemize}

È obbligatorio specificare una delle prime tre modalità. La quinta e
la sesta sono esclusive, non è possibile specificare O\_APPEND se si
specifica O\_TRUNC (e viceversa).Inoltre non si puo' specificare O\_CREAT se
si specifica O\_RDONLY (oppure O\_RDWR).

È possibile specificare una combinazione di modalità semplicemente
sommando i valori interi ad esse associati.  Ad esempio, se si vuole aprire un
file in modalità di sola scrittura ed aggiungere il testo alla fine del
file, si dovrà specificare la modalità 2 + 8 = 10.

Il valore di ritorno delle chiamate di sistema è il nuovo descrittore del
file (file descriptor) associato al file, che potrà essere utilizzato con
le altre chiamate di sistema. Qualora si verifichi un errore, il valore di
ritorno sarà -1.


\subsection{\emph{SYSCALL 2 - close()}}
\label{instructions:syscall-2-close}
SYSCALL 2 richiede solo un parametro, il file descriptor del file che deve
essere chiuso.

Qualora l'operazione termini con successo, SYSCALL 2 ritornerà 0, altrimenti
-1.  Possibili cause di errore sono il tentativo di chiudere un file
inesistente, o di chiudere i file descriptor 0, 1 o 2, che sono associati
rispettivamente allo standard input, allo standard output ed allo standard
error.


\subsection{\emph{SYSCALL 3 - read()}}
\label{instructions:syscall-3-read}
SYSCALL 3 richiede tre parametri: il file descriptor da cui leggere, l'indirizzo
nel quale i dati letti dovranno essere copiati, il numero di byte da leggere.

Se il primo parametro è 0, il simulatore permetterà all'utente di
inserire un valore mediante un'apposita finestra di dialogo.  Se la lunghezza
del valore immesso è maggiore del numero di byte che devono essere letti,
il simulatore mostrerà nuovamente la finestra.

La chiamata di sistema ritorna il numero di byte effettivamente letti, o -1 se
l'operazione di lettura fallisce. Possibili cause di errore sono il tentativo
di leggere da un file inesistente, o di leggere dai file descriptor 1
(standard output) o 2 (standard error), oppure il tentativo di leggere da un
file di sola scrittura.


\subsection{\emph{SYSCALL 4 - write()}}
\label{instructions:syscall-4-write}
SYSCALL 4 richiede tre parametri: il file descriptor su cui scrivere,
l'indirizzo dal quale i dati dovranno essere letti, il numero di byte da
scrivere.

Se il primo parametro è 2 o 3, il simulatore mostrerà la finestra di
input/output dove scriverà i dati letti.

Questa chiamata di sistema ritorna il numero di byte che sono stati scritti, o
-1 se l'operazione di scrittura fallisce.  Possibili cause di errore sono il
tentativo di scrivere su un file inesistente, o sul file descriptor 0
(standard input), oppure il tentativo di scrivere su un file di sola lettura.


\subsection{\emph{SYSCALL 5 - printf()}}
\label{instructions:syscall-5-printf}
SYSCALL 5 richiede un numero variabile di parametri, il primo è la
cosiddetta ``format string'' o stringa di formato. Nella stringa di formato
possono essere inseriti alcuni segnaposto, descritti nella seguente lista:
* \emph{\%s} parametro di tipo stringa;
* \emph{\%i} parametro di tipo intero;
* \emph{\%d} si comporta come \emph{\%i};
* \emph{\%\%} carattere \emph{\%}

Per ciascuno dei segnaposto \emph{\%s}, \emph{\%d} o \emph{\%i} la SYSCALL 5
si aspetta un parametro, partendo dall'indirizzo del precedente.

Quando la SYSCALL trova un segnaposto per un parametro intero, si aspetta che
il corrispondente parametro sia un valore intero, quando trova un segnaposto
per un parametro stringa, si aspetta come parametro l'indirizzo della stringa
stessa.

Il risultato  visualizzato nella finestra di input/output, ed il numero di
byte scritti posto in R1.

Qualora si verifichi un errore, R1 avrà valore -1.


\section{Altre istruzioni}
\label{instructions:altre-istruzioni}
In questa sezione sono descritte istruzioni che non rientrano nelle precedenti
categorie.


\subsection{\emph{BREAK}}
\label{instructions:break}
L'istruzione BREAK solleva un'eccezione che ha l'effetto di fermare
l'esecuzione se il simulatore è in esecuzione. Può essere utilizzata per
il debugging.


\subsection{\emph{NOP}}
\label{instructions:nop}
L'istruzione NOP non fa nulla, ed è utilizzata per creare pause nel codice
sorgente.


\subsection{\emph{TRAP}}
\label{instructions:trap}
L'istruzione TRAP è deprecated, rappresenta un'alternativa all'istruzione
SYSCALL.


\subsection{\emph{HALT}}
\label{instructions:halt}
L'istruzione HALT è deprecated, rappresenta un'alternativa all'istruzione
SYSCALL 0, che ferma il simulatore.


\chapter{L'interfaccia utente}
\label{user-interface:l-interfaccia-utente}\label{user-interface::doc}
L'interfaccia grafica EduMIPS64 si ispira a quella di WinMIPS64. Infatti, la
finestra principale è identica, eccetto che per qualche menù.

La finestra principale di EduMIPS64 è caratterizzata da sei frame, che
mostrano i differenti aspetti della simulazione.  è inoltre presente una
barra di stato, che ha il duplice scopo di mostrare il contenuto delle celle
di memoria e dei registri quando vengono selezionati e di notificare
all'utente che il simulatore è in esecuzione quando la simulazione è
stata avviata ma la modalità verbose  non è stata attivata.  Maggiori
dettagli sono descritti nelle sezioni a seguire.


\section{La barra dei menù}
\label{user-interface:la-barra-dei-menu}
La barra del menù contiene sei opzioni:


\subsection{File}
\label{user-interface:file}
Il menù File contiene comandi per l'apertura dei file, per resettare o
fermare il simulatore e per scrivere i trace file.
\begin{itemize}
\item {} 
\emph{Apri...} Apre una finestra che consente all'utente di scegliere un file
sorgente da aprire.

\item {} 
\emph{Apri recente} Mostra la lista dei file recentemente aperti dal simulatore,
dalla quale l'utente può scegliere il file da aprire.

\item {} 
\emph{Resetta} Inizializza nuovamente il simulatore, mantenendo aperto il file
che era stato caricato ma facendone ripartire l'esecuzione.

\item {} 
\emph{Scrivi Tracefile Dinero...} Scrive i dati di accesso alla memoria in un
file, nel formato xdin.

\item {} 
\emph{Esci} Chiude il simulatore.

\end{itemize}

La voce del menù \emph{Scrivi Tracefile Dinero...} è disponibile solo quando un
file sorgente è stato completamente eseguito ed è stata già raggiunta la fine
dell'esecuzione.


\subsection{Esegui}
\label{user-interface:esegui}
Il menu Esegui contiene voci riguardanti il flusso di esecuzione della
simulazione.
\begin{itemize}
\item {} 
\emph{Ciclo singolo} Esegue un singolo passo di simulazione.

\item {} 
\emph{Completa} Inizia l'esecuzione, fermandosi quando il simulatore
raggiunge una SYSCALL 0 (o equivalente) o un'istruzione di \emph{BREAK},
oppure quando l'utente seleziona la voce Stop del menù (o preme F9).

\item {} 
\emph{Cicli multipli} Esegue un certo numero di passi di simulazione, tale
valore può essere configurato attraverso la finestra di configurazione.

\end{itemize}
\begin{itemize}
\item {} 
\emph{Ferma} Ferma l'esecuzione quando il simulatore è in modalità
``Completa'' o ``Cicli multipli'', come descritto precedentemente.

\end{itemize}

Il menu è disponibile solo quando è stato caricato un file sorgente e
non è ancora stato raggiunto il termine della simulazione.  La voce
\emph{Stop} del menù  disponibile solo in modalità ``Completa'' o
``Cicli multipli'' mode.


\subsection{Configura}
\label{user-interface:configura}
Il menu Configura fornisce l'opportunità di personalizzare l'aspetto ed il
funzionamento di EduMIPS64.
\begin{itemize}
\item {} 
\emph{Impostazioni...} Apre la finestra di configurazione, descritta nella
prossima sezione di questo capitolo;

\item {} 
\emph{Selezione lingua} Consente di modificare la lingua usata
dall'interfaccia utente. Attualmente sono supportate solo inglese ed
italiano. Questa modifica riguarda ogni aspetto dell'interfaccia grafica,
dal titolo delle finestre al manuale in linea ed i messaggi di errore o le
notifiche.

\end{itemize}

La voce di menù \emph{Impostazioni...} non è disponibile quando il
simulatore è in modalità ``Completa'' o ``Cicli multipli'', a causa di
possibili race conditions.


\subsection{Strumenti}
\label{user-interface:strumenti}
Questo menù contiene solo una voce, utilizzata per aprire la finestra del
Dinero frontend.
\begin{itemize}
\item {} 
\emph{Dinero Frontend...} Apre la finestra del Dinero Frontend..

\end{itemize}

Questo menù non è disponibile finchè non è stata portata a
termine l'esecuzione del programma


\subsection{Finestra}
\label{user-interface:finestra}
Questo menù contiene voci relative alle operazioni con le finestre.
\begin{itemize}
\item {} 
\emph{Tile} Ordina le finestre visibili in modo tale che non vi siano
più di tre finestre in una riga, tentando di massimizzare lo spazio
occupato da ciascuna finestra.

\end{itemize}

Le altre voci del menù modificano semplicemente lo stato di ciascuna
finestra, rendendola visibile o riducendola ad icona.


\subsection{Aiuto}
\label{user-interface:aiuto}
Questo menù contiene voci relative all'aiuto in linea.
\begin{itemize}
\item {} 
\emph{Manuale...} Mostra la finestra di help.

\item {} 
\emph{Informazioni su...} Mostra una finestra contenente i nomi di coloro
che hanno collaborato al progetto ed i loro ruoli.

\end{itemize}


\section{Finestre}
\label{user-interface:finestre}
L'interfaccia grafica è composta da sette finestre, sei delle quali sono
visibili per default, mentre una (la finestra di I/O) è nascosta.


\subsection{Cicli}
\label{user-interface:cicli}
La finestra Cicli mostra l'evoluzione del flusso di esecuzione nel tempo,
visualizzando in ogni istante quali istruzioni sono nella pipeline, ed in
quale stadio si trovano.


\subsection{Registri}
\label{user-interface:registri}
La finestra Registri mostra il contenuto di ciascun registro. Mediante un
click col tasto sinistro del mouse è possibile vedere il loro valore
decimale (con segno) nella barra di stato, mentre con un doppio click
verrà aperta una finestra di dialogo che consentirà all'utente di
cambiare il valore del registro


\subsection{Statistics}
\label{user-interface:statistics}
La finestra Statistiche mostra alcune statistiche riguardanti l'esecuzione del
programma.


\subsection{Pipeline}
\label{user-interface:pipeline}
La finestra Pipeline mostra lo stato attuale della pipeline, visualizzando
ciascuna istruzione con il suo stadio.  I differenti colori evidenziano i vari
stadi della pipeline stessa.


\subsection{Memoria}
\label{user-interface:memoria}
La finestra Memoria mostra il contenuto delle celle di memoria, insieme alle
etichette ed i commenti, tratti dal codice sorgente. Il contenuto delle celle
di memoria, come per i registri, può essere modificato con un doppio
click, e mediante un singolo click del mouse verrà mostrato il loro valore
decimale nella barra di stato.  La prima colonna mostra l'indirizzo
esadecimale della cella di memoria, e la seconda il valore della cella stessa.
Le altre colonne mostrano invece informazioni addizionali provenienti dal
codice sorgente.


\subsection{Codice}
\label{user-interface:codice}
La finestra Codice visualizza le istruzioni caricate in memoria.. La prima
colonna mostra l'indirizzo dell'istruzione, mentre la seconda mostra la
rappresentazione esadecimale dell'istruzione stessa. Le altre colonne mostrano
infine informazioni addizionali provenienti dal codice sorgente.


\subsection{Input/Output}
\label{user-interface:input-output}
La finestra Input/Output fornisce un'interfaccia all'utente per la
visualizzazione dell'output creato dai programmi mediante le SYSCALL 4 e 5.
Attualmente non è utilizzata per l'input di dati, ed al suo posto viene
utilizzata una finestra di dialogo che viene mostrata quando una SYSCALL 3
tenta di leggere dallo standard input, ma future versioni includeranno una
casella di testo per l'input.


\section{Finestre di dialogo}
\label{user-interface:finestre-di-dialogo}
Le finestre di dialogo sono utilizzate da EduMIPS64 per interagire con l'utente
in vari modi. Ecco un riassunto delle più importanti:


\subsection{Impostazioni}
\label{user-interface:impostazioni}
Nella finestra di configurazione possono essere configurati vari aspetti del
simulatore.

La sezione ``Impostazioni generali'' consente di configurare il forwarding ed il
numero di passi da effettuare nella modalità Cicli multipli.

La sezione ``Comportamento'' permette di abilitare o disabilitare gli avvisi
durante la fase di parsing, l'opzione ``sincronizza la GUI con la CPU
nell'esecuzione multi step'', quando abilitata, sincronizzerà lo stato
grafico delle finestre con lo stato interno del simulatore. Ciò
implicherà una simulazione più lenta, ma con la possibilità di
avere un resoconto grafico esplicito di ciò che sta avvenendo durante la
simulazione.  L'opzione ``intervallo tra i cicli'', qualora sia abilitata,
influenzerà il numero di millisecondi che il simulatore dovrà
attendere prima di cominciare un nuovo ciclo. Tali opzioni hanno effetto solo
quando la simulazione è avviata utilizzando le opzioni ``Completa'' o ``Cicli
multipli'' dal menu Esegui.

Le ultime due opzioni stabiliscono il comportamento del simulatore quando si
verifica un'eccezione sincrona.  è importante notare che se le eccezioni
sincrone sono mascherate, non succederà nulla, anche se l'opzione ``Termina
se si verifica un'eccezione sincrona'' è abilitata. Se le eccezioni non
sono mascherate e tale opzione è abilitata, apparirà una finestra di
dialogo, e la simulazione sarà fermata non appena tale finestra verrà
chiusa.

L'ultima sezione permette di modificare i colori associati ai diversi stadi
della pipeline. Abbastanza inutile, ma carino.


\subsection{Dinero Frontend}
\label{user-interface:dinero-frontend}
La finestra di dialogo Dinero Frontend consente di avviare un processo
DineroIV con il trace file generato internamente mediante l'esecuzione del
programma. Nella prima casella di testo c'è il percorso dell'eseguibile
DineroIV, e nella seconda devono essere inseriti i parametri opportuni.

La sezione più in basso contiene l'output del processo DineroIV, dal quale
è possibile prelevare i dati di cui si necessita.


\subsection{Aiuto}
\label{user-interface:id1}
La finestra di Aiuto contiene tre sezioni con qualche indicazione riguardo
l'utilizzo del simulatore.  La prima è una breve introduzione ad
EduMIPS64, la seconda contiene informazioni riguardanti l'interfaccia grafica
e la terza contiene un riassunto delle istruzioni supportate.


\section{Opzioni da riga di comando}
\label{user-interface:opzioni-da-riga-di-comando}
Sono disponibili tre opzioni da linea di comando. Esse sono descritte di
seguito, con il nome per esteso scritto tra parentesi.  Nomi abbreviati e per
esteso possono essere utilizzati indifferentemente.
\begin{itemize}
\item {} 
\emph{-h (--help)} mostra un messaggio di aiuto contenente la versione del
simulatore ed un breve riassunto delle opzioni da linea di comando.

\item {} 
\emph{-f (--file) filename} apre \emph{filename} nel simulatore.

\item {} 
\emph{-d (--debug)} attiva la modalità di debugging.

\end{itemize}

Nella modalità di debugging è disponibile una nuova finestra, la finestra
Debug, che mostra il resoconto delle attività interne di  EduMIPS64. Tale
finestra non è utile per l'utente finale, è stata infatti ideata per
poter essere utilizzata dagli sviluppatori di EduMIPS64.


\section{Eseguire EduMIPS64}
\label{user-interface:eseguire-edumips64}
Il file \emph{.jar} di EduMIPS64 può funzionare sia come file .jar
eseguibile che come applet, quindi può essere eseguito in entrambi i modi,
che richiedono il Java Runtime Environment, versione 5 o successiva.

Per eseguire il file come applicazione a sè stante, l'eseguibile
\emph{java} deve essere avviato nel seguente modo: \emph{java -jar
edumips64-version.jar}, dove la stringa \emph{version} deve essere
sostituita con la versione attuale del simulatore.  Su alcuni sistemi,
potrebbe essere possibile eseguire il programma semplicemente con un click sul
file \emph{.jar}.

Per eseguire il file come applet deve essere utilizzato il tag
\emph{\textless{}applet\textgreater{}}. Il sito web di EduMIPS64 presenta una pagina già contenente
l'applet, in modo tale che chiunque possa eseguire il programma senza il
problema dell'utilizzo da linea di comando.


\chapter{Listati di esempio}
\label{examples::doc}\label{examples:listati-di-esempio}
In questo capitolo sono presenti degli esemi di codice utili per comprendere
il funzionamento del simulatore.


\section{SYSCALL}
\label{examples:syscall}
Gli esempi per le SYSCALL 1-4 si riferiscono al file \emph{print.s}, che è
l'esempio per la SYSCALL 5. Se si desidera eseguire gli esempi, è prima
necessario copiare il contenuto di quell'esempio in un file denominato
\emph{print.s}, e salvarlo nella stessa directory contenente l'esempio che si sta
eseguendo.

Alcuni esempi si aspettano che esista un file descriptor, e non contengono il
codice per aprire alcun file. Per eseguire questi esempi, eseguire prima la
SYSCALL 1.


\subsection{SYSCALL 0}
\label{examples:syscall-0}
L'effetto dell'esecuzione della SYSCALL 0 è l'interruzione dell'esecuzione del programma.
Esempio:

\begin{Verbatim}[commandchars=@\[\]]
.code
daddi   r1, r0, 0    ; salva il valore 0 in R1
syscall 0            ; termina l'esecuzione
\end{Verbatim}


\subsection{SYSCALL 1}
\label{examples:syscall-1}
Programma d'esempio che apre un file:

\begin{Verbatim}[commandchars=@\[\]]
                .data
error@_op:       .asciiz     "Errore durante l'apertura del file"
ok@_message:     .asciiz     "Tutto ok."
params@_sys1:    .asciiz     "filename.txt"
                .word64     0xF

                .text
open:           daddi       r14, r0, params@_sys1
                syscall     1
                daddi       @$s0, r0, -1
                dadd        @$s2, r0, r1
                daddi       @$a0,r0,ok@_message
                bne         r1,@$s0,end
                daddi       @$a0,r0,error@_op

end:            jal         print@_string
                syscall 0

                @#include    print.s
\end{Verbatim}

Nelle prime due righe, vengono salvate in memoria le stringhe che contengono
i messaggi di errore e di successo, che saranno poi passati come parametri
alla funzione \emph{print\_string}, ed a ciascuno di essi viene associata
un'etichetta. La funzione \emph{print\_string} è presente nel file \emph{print.s}.

Successivamente, vengono salvati in memoria i dati richiesti dalla SYSCALL 1,
il percorso del file da aprire (che deve esistere se si apre il file in
modalità sola lettura o lettura/scrittura) e, nella cella successiva, un
intero che definisce la modalità di apertura.

In questo esempio, il file è stato aerto utilizzando la seguente modalità:
\emph{O\_RDWR} \textbar{} \emph{O\_CREAT} \textbar{} \emph{O\_APPEND}. Il numero 15 (0xF in base 16) deriva dalla
somma dei valori di queste tre modalità modes (3 + 4 + 8).

Questi due parametri hanno un'etichetta, in modo che in seguito possano essere
utilizzati.

Nella sezione .text, come prima cosa l'indirizzo di \emph{param\_sys1} - che per il
compilatore è un numero - viene salvato in r14; successivamente viene chiamata
la SYSCALL 1, ed il contenuto di R1 viene salvato nel registro \$s2, in modo
che possa essere utilizzato nel resto del programma (ad esempio, con un'altra
SYSCALL).

Infine viene chiamata la funzione \emph{print\_string}, passando come parametro
\emph{error\_op} se R1 contiene il valore -1 (righe 13-14), altrimenti utlizzando
\emph{ok\_message} (righe 12-16).


\subsection{SYSCALL 2}
\label{examples:syscall-2}
Programma di esempio che chiude un file:

\begin{Verbatim}[commandchars=@\[\]]
                .data
params@_sys2:    .space 8
error@_cl:       .asciiz     "Errore durante la chiususra del file"
ok@_message:     .asciiz     "Tutto a posto"

                .text
close:          daddi       r14, r0, params@_sys2
                sw          @$s2, params@_sys2(r0)
                syscall     2
                daddi       @$s0, r0, -1
                daddi       @$a0, r0, ok@_message
                bne         r1, @$s0, end
                daddi       @$a0, r0, error@_cl

end:            jal         print@_string
                syscall     0

                @#include    print.s
\end{Verbatim}

\textbf{Nota:} Questo esempio richiede che in \$s2 ci sia il file descriptor del
file da chiudere.

Come prima cosa viene allocata della memoria per l'unico parametro di SYSCALL
2, il file descriptor del file da chiudere, e a questo spazio viene associata
un'etichetta in modo da potervicisi riferire successivamente.

Successivamente vengono salvate in memoria le stringhe contenenti i messaggi
di successo e di errore.

Nella sezione .text, l'indirizzo di \emph{param\_sys2} viene salvato in R14;
successivamente viene chiamata la SYSCALL 2.

Infine viene chiamata la funzione \emph{print\_string}, stampando il messaggio
d'errore se ci sono problemi (riga 13) o, se tutto è andato a buon fine, il
messaggio di successo (riga 11).


\subsection{SYSCALL 3}
\label{examples:syscall-3}
Programma di esempio che legge 16 byte da un file e li salva in memoria:

\begin{Verbatim}[commandchars=@\[\]]
                .data
params@_sys3:    .space      8
ind@_value:      .space      8
                .word64     16
error@_3:        .asciiz     "Errore durante la lettura da file."
ok@_message:     .asciiz     "Tutto ok."

value:          .space      30

                .text
read:           daddi       r14, r0, params@_sys3
                sw          @$s2, params@_sys3(r0)
                daddi       @$s1, r0, value
                sw          @$s1, ind@_value(r0)
                syscall     3
                daddi       @$s0, r0, -1
                daddi       @$a0, r0,ok@_message
                bne         r1, @$s0,end
                daddi       @$a0, r0,error@_3

end:            jal         print@_string
                syscall     0

                @#include    print.s
\end{Verbatim}

Le prime 4 righe della sezione .data contengono i parametri della SYSCALL 3,
il file descriptor da cui si devono leggere i dati, l'indirizzo della cella di
memoria dove la SYSCALL deve salvare i dati letti, il numero di byte da
leggere. Successivamente sono presenti in memoria i messaggi di successo e di
errore.

Nella sezione .text, come prima cosa viene salvato l'indirizzo di \emph{param\_sys3}
in r14, il file descriptor viene salvato nell'area di memoria dedicata ai
parametri della SYSCALL, ed a seguire lo stesso destino tocca all'indirizzo
dell'area di memoria adibita a contenere i dati letti.

Successivamente viene chiamata la SYSCALL 3 e viene stampato un messaggio di
successo o di errore, a seconda dell'esito della SYSCALL.


\subsection{SYSCALL 4}
\label{examples:syscall-4}
Programma di esempio che scrive su file una stringa:

\begin{Verbatim}[commandchars=@\[\]]
                .data
params@_sys4:    .space      8
ind@_value:      .space      8
                .word64     16
error@_4:        .asciiz     "Errore durante la scrittura su stringa."
ok@_message:     .asciiz     "Tutto ok."
value:          .space      30

                .text

write:          daddi       r14, r0,params@_sys4
                sw          @$s2, params@_sys4(r0)
                daddi       @$s1, r0,value
                sw          @$s1, ind@_value(r0)
                syscall     4
                daddi       @$s0, r0,-1
                daddi       @$a0, r0,ok@_message
                bne         r1, @$s0,end
                daddi       @$a0, r0,error@_4

end:            jal         print@_string
                syscall     0

                @#include    print.s
\end{Verbatim}

La struttura di quest'esempio è identica a quella dell'esempio di SYSCALL 3.


\subsection{SYSCALL 5}
\label{examples:syscall-5}
Programma di esempio che contiene una funzione che stampa su standard output la
stringa contenuta nell'indirizzo di memoria a cui punta \$a0:

\begin{Verbatim}[commandchars=@\[\]]
                .data
params@_sys5:    .space  8

                .text
print@_string:
                sw      @$a0, params@_sys5(r0)
                daddi   r14, r0, params@_sys5
                syscall 5
                jr      r31
\end{Verbatim}

La seconda riga alloca spazio per la stringa che sarà stampata dalla SYSCALL,
che è riempito dalla prima istruzione della sezione .text, che assume che
l'indirizzo della stringa da stampare sia in \$a0.

L'istruzione successiva salva in r14 l'indirizzo di questa stringa, e
successivamente la SYSCALL 5 viene chiamata, stampando quindi la stringa.
L'ultima istruzione varia il program counter, impostandolo al valore di r31 -
che secondo le convenzioni di chiamata di funzione MIPS contiene l'indirizzo
dell'istruzione successiva alla chiamata di funzione.


\subsection{Un esempio di utilizzo della SYSCALL 5 più complesso}
\label{examples:un-esempio-di-utilizzo-della-syscall-5-piu-complesso}
La SYSCALL 5 utilizza un meccanismo di passaggio parametri non semplicissimo,
che sarà illustrato nel seguente esempio:

\begin{Verbatim}[commandchars=@\[\]]
                .data
format@_str:     .asciiz   "@%d @%s:\nTest di @%s versione @%i.@%i!"
s1:             .asciiz   "Giugno"
s2:             .asciiz   "EduMIPS64"
fs@_addr:        .space    4
                .word     5
s1@_addr:        .space    4
s2@_addr:        .space    4
                .word     0
                .word     5
test:
                .code
                daddi     r5, r0, format@_str
                sw        r5, fs@_addr(r0)
                daddi     r2, r0, s1
                daddi     r3, r0, s2
                sd        r2, s1@_addr(r0)
                sd        r3, s2@_addr(r0)
                daddi     r14, r0, fs@_addr
                syscall   5
                syscall   0
\end{Verbatim}

L'indirizzo di memoria della stringa di formato viene inserito in R5, il cui
contenuto viene quindi salvato in memoria all'indirizzo \emph{fs\_addr}. Gli
indirizzi dei parametri di tipo stringa sono salvato in \emph{s1\_addr} ed
\emph{s2\_addr}. Questi due parametri saranno inseriti al posto dei due segnaposto
\emph{\%s} all'interno della stringa di formato.

Nel caso di stringhe di formato complesse, come mostrato da questo esempio, le
word che corrispondono ai segnaposto vanno inserite in memoria subito dopo
l'indirizzo della stringa di formato.



\renewcommand{\indexname}{Index}
\printindex
\end{document}

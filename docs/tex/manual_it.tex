\documentclass[12pt]{report}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{indentfirst}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[italian]{babel}
\newcommand{\EM}{EduMIPS64}
\newcommand{\EV}{0.5}
\newcommand{\MS}{MIPS64}
\newcommand{\SC}{\texttt{SYSCALL}}
\newcommand{\WARN}{\textbf{ATTENZIONE:} Questa \`{e} un'istruzione deprecated, che
non appartiene al repertorio delle istruzioni \MS{}, ma \`{e} stata inclusa nel set di
istruzioni per mantenere la compatibilit\`{a} con altri simulatori.}
\newcommand{\MISN}{\textbf{NB:} La 'U' dell'istruzione sta per 'unsigned'; tuttavia questo \`{e} 
un nome equivoco, perch\'{e} l'operazione considera i valori con segno. La sua caratteristica \`{e} 
quella di non lanciare eccezioni (nemmeno in caso di overflow).}

\lstdefinelanguage{MIPS64}%
{keywords={add, addi, addiu, addu, and, andi, b, beq, beqz, bgez, bne, bnez, break,% 
 bubble, dadd, daddi, daddu, daddiu, daddui, ddiv, ddivu, div, divu, dmult, dmultu,% 
 dsll, dsllv, dsra, dsrav, dsrl, dsrlv, dsub, dubu, halt, j, jal, jalr, jr, lb, lbu, lh, lhu, lw, lwu,%
 ld, lui, mfhi, mflo, movn, movz, mult, multu, nop, or, ori, sb, sh, sw, sd, sll, sllv, slt, slti,%
 sltiu, sltu, sra, srav, srl, srlv, sub, subu, syscall, trap, xor, xori},%
 comment=[l];,%
 directives={.data, .text, .ascii, .asciiz, .space, .byte, .half, .word, .word32, .word64, .double}%
}[keywords,comments,strings,directives]%


% Per avere il bold typewriter
\DeclareFontShape{OT1}{cmtt}{bx}{n}{ <5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinestyle{mips}{
	language=MIPS64,
	numbers=left,
	basicstyle=\small,
	keywordstyle=\bfseries,
	identifierstyle=\ttfamily,
	stringstyle=\ttfamily,
	captionpos=b,
	abovecaptionskip=15pt,
	showstringspaces=false
}
\lstdefinestyle{java}{
	language=java,
	numbers=left,
	basicstyle=\small,
	keywordstyle=\bfseries,
	identifierstyle=\ttfamily,
	stringstyle=\ttfamily,
	captionpos=b,
	abovecaptionskip=15pt,
	showstringspaces=false
}

\usepackage{subfigure}
\usepackage[top=5.3cm, bottom=2cm, left=4cm, right=3cm]{geometry}

\makeindex

\author{Andrea Spadaccini\\Traduzione italiana di Simona Ullo}
\title{Manuale Utente EduMIPS64 \EV}

\hyphenation{mo-di-fica}
\hyphenation{vi-sua-liz-zan-do}
\hyphenation{dia-lo-go}

\begin{document}
\setlength{\baselineskip}{1.60\baselineskip} % interlinea

\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
%\addtolength{\textwidth}{-\centeroffset}
\thispagestyle{empty}
\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\Huge\bfseries Manuale utente di EduMIPS64
}
\noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
\end{minipage}}

\vspace{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\bfseries 
di Andrea Spadaccini\\[1.5ex]
ed il team di EduMIPS64\\[3ex]
} 
Traduzione italiana di Simona Ullo\\[3ex]
Versione~1.3, 5 Giugno 2007
\end{minipage}}

%\addtolength{\textwidth}{\centeroffset}
\vspace{\stretch{2}}


\pagebreak
% END OF TITLEPAGE

\tableofcontents
\listoftables
\lstlistoflistings
\chapter*{Introduzione}
\EM{} \`e un simulatore di Instruction Set Architecture (ISA) \MS{}. \`E stato
progettato per eseguire piccoli programmi che utilizzino il sottoinsieme
dell'Instruction Set \MS{} implementato dal simulatore stesso, permettendo
all'utente di vedere come le istruzioni si comportino nella pipeline, come gli
stalli siano gestiti dalla CPU, lo stato di registri e memoria e molto altro.
\`E classificabile sia come simulatore, sia come debugger visuale.

\EM{} \`e stato progettato e sviluppato da un gruppo di studenti
dell'Universit\`a degli Studi di Catania, ed ha tratto spunto, come interfaccia
e come funzionamento, dal simulatore WinMIPS64, sebbene vi siano alcune
differenze importanti con quest'ultimo.

Questo manuale vi introdurr\`a ad \EM{}, e spiegher\`a come utilizzarlo.

Il primo capitolo del manuale riguarda il formato dei file sorgente accettato
dal simulatore, descrivendo i tipi di dato e le direttive, oltre ai parametri da
linea di comando.

Nel secondo capitolo \`{e} presentata una panoramica del set di istruzioni
\MS{} utilizzato da \EM{}, con tutti i parametri richiesti e le indicazioni per
il loro utilizzo.

Il terzo capitolo \`{e} una descrizione dell'interfaccia utente di \EM{}, che
espone lo scopo di ciascuna finestra e di ciascun men\`{u}, insieme ad una
descrizione delle finestre di configurazione, del Dinero frontend, del manuale e
delle opzioni da linea di comando. 

Il quarto capitolo contiene alcune esempi pratici di utilizzo del simulatore.

Questo manuale si riferisce ad EduMIPS64 versione \EV{}

\chapter{Formato dei file sorgenti}
\EM{} si propone di seguire le convenzioni usate negli altri simulatori \MS{} e DLX, 
in modo tale da non creare confusione riguardante la sintassi per i vecchi utenti.

\section{Sezioni}
\index{.data}\index{.code}
All'interno di un file sorgente sono presenti due sezioni: quella dedicata ai \textbf{dati} 
e quella in cui \`{e} contenuto il \textbf{code}, introdotte rispettivamente dalle direttive \textbf{.data} e
\textbf{.code}. Nel listato~\ref{code:sample} \`{e} possibile vedere un semplice programma 
\EM{}.

Per distinguere le varie parti di ciascuna linea di codice, pu\`{o} essere utilizzata una qualunque combinazione di spazi e tabulazioni.

\begin{lstlisting}[caption={Esempio di codice \EM{}}, label={code:sample}, style={mips}]
; Questo e' un commento
        .data
label:  .word   15     ; Questo e' un commento in linea

        .code
        daddi   r1, r0, 0
        syscall 0
\end{lstlisting}

\index{commenti}\index{;}
I commenti possono essere introdotti utilizzando il carattere ``;'' qualsiasi
cosa venga scritta successivamente ad esso verr\`{a} ignorata.  Un commento
pu\`{o} quindi essere usato ``inline'' (dopo una direttiva) oppure in una riga a
s\`{e} stante.

\index{etichette} Le etichette possono essere usate nel codice per fare
riferimento ad una cella di memoria o ad un'istruzione.  Esse sono case
insensitive. Per ciascuna linea di codice pu\`{o} essere utilizzata un'unica
etichetta. Quest'ultima pu\`{o} essere inserita una o pi\`{u} righe al di sopra
dell'effettiva dichiarazione del dato o dell'istruzione, facendo in modo che non
ci sia nulla, eccetto commenti e linee vuote, tra l'etichetta stessa e la
dichiarazione. 

\subsection{La sezione \texttt{.data}}
\index{.data}
La sezione \textbf{data} contiene i comandi che specificano il modo in cui la
memoria deve essere riempita prima dell'inizio dell'esecuzione del programma. La
forma generale di un comando \texttt{.data} \`{e}:

\begin{center}
	\texttt{[etichetta:] \textbf{.tipoDiDato} valore1 [, valore2 [, ...]]}
\end{center}

\EM{} supporta diversi tipi di dato, che sono descritti nella tabella~\ref{table:datatypes}.

\index{tipi di dato}
\index{.byte}
\index{.word}
\index{.word16}
\index{.word32}
\index{.word64}
\begin{table}[!htb]
	\begin{centering}
		\begin{tabular}{lll}
			\hline
			\hline
			Tipo & Direttiva & Bit richiesti\\
			\hline
			Byte & \texttt{.byte} & 8\\
			Half word & \texttt{.word16} & 16\\
			Word & \texttt{.word32} & 32\\
			Double Word & \texttt{.word} o \texttt{.word64} & 64
		\end{tabular}
		\caption{Tipi di dato}
		\label{table:datatypes}
	\end{centering}
\end{table}

Dati di tipo doubleword possono essere introdotti sia dalla direttiva
\texttt{.word} che dalla direttiva \texttt{.word64}.

\index{array} Esiste una differenza sostanziale tra la dichiarazione di una lista di dati 
utilizzando un'unica direttiva oppure direttive multiple dello stesso tipo.
\EM{} inizia la scrittura a partire dalla successiva double word a 64 bit non appena 
trova un identificatore del tipo di dato, in tal modo la prima istruzione \texttt{.byte} 
del listato~\ref{code:data_array} inserir\`{a} i numeri 1, 2, 3 e 4 nello spazio di 4 byte, 
occupando 32 bit, mentre il codice delle successive quattro righe inserir\`{a} ciascun numero 
in una differente cella di memoria, occupando 32 byte, come specificato nella tabella~\ref{table:effect}.

\begin{lstlisting}[caption={Byte adiacenti}, label={code:data_array}, style={mips}]
	.data
	.byte	1, 2, 3, 4
	.byte	1
	.byte	2
	.byte	3
	.byte	4
\end{lstlisting}

Nella tabella~\ref{table:effect}, la memoria \`{e} rappresentata utilizzando celle di dimensione pari 
ad 1 byte e ciascuna riga \`{e} lunga 64 bit. L'indirizzo posto alla sinistra di ogni riga della tabella \`{e} 
riferito alla cella di memoria pi\`{u} a destra, che possiede l'indirizzo pi\`{u} basso rispetto alle otto celle in ciascuna linea.

\begin{table}[htb]
	\begin{centering}
		\begin{tabular}{r|c|c|c|c|c|c|c|c|}
			\cline{2-9}
			0 & 0 & 0 & 0 & 0 &4 & 3 &2 &1 \\
			\cline{2-9}
			8 & 0 & 0 & 0 & 0 &0 & 0 &0 &1 \\
			\cline{2-9}
			16 & 0 & 0 & 0 & 0 &0 & 0 &0 &2 \\
			\cline{2-9}
			24 & 0 & 0 & 0 & 0 &0 & 0 &0 &3 \\
			\cline{2-9}
			36 & 0 & 0 & 0 & 0 &0 & 0 &0 &4\\ 
			\cline{2-9}
		\end{tabular}
		\caption{Stato della memoria per il listato~\ref{code:data_array}}
		\label{table:effect}
	\end{centering}
\end{table}
Ci sono alcune direttive speciali che devono essere discusse: \texttt{.space}, 
\texttt{.ascii} e \texttt{.asciiz}.
\index{.space}
La direttiva \texttt{.space} \`{e} usata per lasciare dello spazio vuoto in memoria. 
Essa accetta un intero come parametro, che indica il numero di byte che devono essere lasciati liberi. 
Tale direttiva \`{e} utile quando \`{e} necessario conservare dello spazio in memoria per i risultati dei propri calcoli.

\index{.ascii}
La direttiva \texttt{.ascii} accetta stringhe contenenti un qualunque carattere ASCII, 
ed alcune ``sequenze di escape'', simili a quelle presenti nel linguaggio C, che sono descritte nella 
tabella~\ref{table:escaping}, ed inserisce tali stringhe in memoria.

\index{.asciiz}
La direttiva \texttt{.asciiz} si comporta esattamente come il comando \texttt{.ascii},
con la differenza che essa pone automaticamente alla fine della stringa un byte nullo.

\begin{table}[!htb]
	\begin{tabular}{lll}
		\hline
		\hline
		Sequenza di escape & Significato & Codifica ASCII\\
		\hline
		\texttt{$\backslash$0} & Byte nullo & 0\\
		\texttt{$\backslash$t} & Tabulazione orizzontale & 9\\
		\texttt{$\backslash$n} & Nuova linea & 10\\
		\texttt{$\backslash$}`` & Apici doppi & 34\\
		\texttt{$\backslash\backslash$} & Backslash & 92
	\end{tabular}
	\caption{Sequenze di escape}
	\label{table:escaping}
\end{table}

\subsection{La sezione \texttt{.code}}
\index{.code}
La sezione \textbf{code} contiene comandi che specificano come la memoria debba essere riempita 
quando il programma verr\`{a} eseguito. La forma generale di un comando \texttt{.code} \`{e}:

\index{sintassi!parametri istruzioni}
\begin{center}
	\texttt{[etichette:] \textbf{istruzione} [param1 [, param2 [, param3]]]}
\end{center}

\index{.text} pu\`{o} essere indicata anche con la direttiva \texttt{.text}.

Il numero e il tipo di parametri dipendono dall'istruzione stessa. 
%Please see table~\ref{table:segm-type} for the list of possible parameters.

Le istruzioni possono accettare tre tipi di parametri:
\begin{itemize}
	\item \textbf{Registri} un parametro di tipo registro \`e indicato da una
    ``r'' maiuscola o minuscola, o da un carattere ``\$'', a fianco del numero
    di registro (tra 0 e 31). Ad esempio, le scritture ``r4'', ``R4'' e ``\$4''
    identificano tutt'e tre il quarto registro;
	\item \textbf{Valori immediati} un valore immediato pu\`o essere un numero o
    un'etichetta; il numero pu\`o essere specificato in base 10 o in base 16. I
    numeri in base 10 sono inseriti semplicemente scrivendo il numero
    utilizzando l'usuale notazione decimale; i numeri in base 16 si inseriscono
    aggiungendo all'inizio del numero il prefisso ``0x'';
    \item \textbf{Indirizzi} un indirizzo \`e composto da un valore immediato
    seguito dal nome di un registro tra parentesi. Il valore del registro sar\`a
    usato come base, quello dell'immediato come offset.
\end{itemize}

La dimensione dei valori immediati \`{e} limitata al numero di bit disponibili
nella codifica associata all'istruzione. 

\`E possibile utilizzare gli alias standard MIPS per i primi 32 registri,
mettendo in coda ai prefissi standard per i registri (``r'', ``\$'', ``R'') uno
degli alias indicati in tabella~\ref{table:mips32-reg}

\index{registri}
\begin{table}[!htb]
	\begin{centering}
		\begin{tabular}{ll}
			\hline
			\hline
			Registro & Alias\\
			\hline
			0 & \texttt{zero}\\
			1 & \texttt{at}\\
			2 & \texttt{v0}\\
			3 & \texttt{v1}\\
			4 & \texttt{a0}\\
			5 & \texttt{a1}\\
			6 & \texttt{a2}\\
			7 & \texttt{a3}\\
			8 & \texttt{t0}\\
			9 & \texttt{t1}\\
			10 & \texttt{t2}\\
			11 & \texttt{t3}\\
			12 & \texttt{t4}\\
			13 & \texttt{t5}\\
			14 & \texttt{t6}\\
			15 & \texttt{t7}\\
			16 & \texttt{s0}\\
			17 & \texttt{s1}\\
			18 & \texttt{s2}\\
			19 & \texttt{s3}\\
			20 & \texttt{s4}\\
			21 & \texttt{s5}\\
			22 & \texttt{s6}\\
			23 & \texttt{s7}\\
			24 & \texttt{t8}\\
			25 & \texttt{t9}\\
			26 & \texttt{k0}\\
			27 & \texttt{k1}\\
			28 & \texttt{gp}\\
			29 & \texttt{sp}\\
			30 & \texttt{fp}\\
			31 & \texttt{ra}\\
		\end{tabular}
		\caption{Alias per i primi 32 registri}
		\label{table:mips32-reg}
	\end{centering}
\end{table}

%Please see~\cite{mips-2} for more details about how instruction are actually encoded.

Le istruzioni che possono essere utilizzate in questa sezione saranno discusse nella sezione~\ref{instructions}

\subsection{Il comando \texttt{\#include}}
I sorgenti possono includere il comando \texttt{\textbf{\#include} nomefile}, che
ha l'effetto di inserire, al posto della riga contenente questo comando, il
contenuto del file \texttt{nomefile}.
Questo comando \`e utile se si vogliono includere delle funzioni esterne, ed \`e
dotato di un algoritmo di rilevamento dei cicli, che impedisce di eseguire
inclusioni circolari tipo ``\texttt{\#include A.s}'' nel file \texttt{B.s} e
``\texttt{\#include B.s}'' nel file \texttt{A.s}.

\chapter{Il repertorio delle istruzioni}
\label{instructions}
\index{istruzioni}

In questa sezione verr\`{a} illustrato il repertorio delle istruzioni \MS{} riconosciute da \EM{}.
\`{E} possibile effettuare due differenti classificazioni: una basata sulla funzionalit\`{a} delle istruzioni e 
l'altra basata sul tipo di parametri.

% Please refer to Section~\ref{mipsis} for more informations about those classifications.

La prima classificazione suddivide le istruzioni in tre categorie: istruzioni ALU, istruzioni Load/Store, 
istruzioni di controllo del flusso. I prossimi tre paragrafi descriveranno ciascuna categoria e le istruzioni che vi appartengono.

Il quarto paragrafo descriver\`{a} le istruzioni che non rientrano in nessuna delle tre categorie sopraelencate.

%For a more complete \MS{} instruction set reference, please refer to~\cite{mips-2}.

\section{Istruzioni ALU}
L'unit\`{a} logico-aritmetica (ALU) fa parte dell'unit\`{a} esecutiva di una CPU ed assume il ruolo di esecuzione 
di operazioni logiche ed aritmetiche. Il gruppo di istruzioni ALU conterr\`{a} quindi quelle istruzioni 
che effettuano questo tipo di operazioni.

Le istruzioni ALU possono essere suddivise in due gruppi: \textbf{tipo R} e \textbf{tipo I}. 

\index{istruzioni!istruzioni ALU}
\index{LO}
\index{HI}
\index{registri!LO}
\index{registri!HI}
Quattro di esse utilizzano due registri speciali: LO e HI. Tali registri sono interni alla CPU ed \`{e} 
possibile accedere al loro valore mediante le istruzioni \texttt{MFLO} e \texttt{MFHI}.

Ecco la lista delle istruzioni ALU di tipo R.

\begin{itemize}
	\index{AND}
	\index{istruzioni!AND}
	\item \texttt{AND rd, rs, rt}\\
	Esegue un AND bit a bit tra rs ed rt, e pone il risultato in rd.
	
	\index{ADD}
	\index{instruzioni!ADD}
	\item \texttt{ADD rd, rs, rt}\\
	Somma il contenuto dei registri a 32-bit rs ed rt, considerandoli come valori con segno, e pone il risultato in rd.
	Lancia un eccezione in caso di overflow.

	\index{ADDU}
	\index{instruzioni!ADDU}
	\item \texttt{ADDU rd, rs, rt}\\
	Somma il contenuto dei registri a 32-bit rs ed rt, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DADD}
	\index{istruzioni!DADD}
	\item \texttt{DADD rd, rs, rt}\\
	Somma il contenuto dei registri a 64-bit rs ed rt, considerandoli come valori con segno, e pone il risultato in rd.
	Lancia un eccezione in caso di overflow.

	\index{DADDU}
	\index{istruzioni!DADDU}
	\item \texttt{DADDU rd, rs, rt}\\
	Somma il contenuto dei registri a 64-bit rs ed rt, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DDIV}
	\index{istruzioni!DDIV}
	\item \texttt{DDIV rs, rt}\\
	Esegue la divisione tra i registri a 64-bit rs ed rt, ponendo i 64-bit del quoziente
	in LO ed i 64-bit del resto in HI.

	\index{DDIVU}
	\index{istruzioni!DDIVU}
	\item \texttt{DDIVU rs, rt}\\
    	Esegue la divisione tra i registri a 64-bit rs ed rt, considerandoli come valori senza segno e
    	ponendo i 64-bit del quoziente in LO ed i 64-bit del resto in HI.

	\index{DIV}
	\index{istruzioni!DIV}
	\item \texttt{DIV rs, rt}\\
	Esegue la divisione tra i registri a 32-bit rs ed rt, ponendo i 32-bit del quoziente
	in LO ed i 32-bit del resto in HI.

	\index{DIVU}
	\index{istruzioni!DIVU}
	\item \texttt{DIVU rs, rt}\\
    	Esegue la divisione tra i registri a 32-bit rs ed rt, considerandoli come valori senza segno e
    	pone i 32-bit del quoziente in LO ed i 32-bit del resto in HI.
	
	\index{DMULT}
	\index{istruzioni!DMULT}
	\item \texttt{DMULT rs, rt}\\
	Esegue il prodotto tra i registri a 64-bit rs ed rt, ponendo i 64 bit bassi del risultato nel registro speciale LO
	e i 64 bit alti del risultato nel registro speciale HI.

	\index{DMULTU}
	\index{istruzioni!DMULTU}
	\item \texttt{DMULTU rs, rt}\\
	Esegue il prodotto tra i registri a 64-bit rs ed rt, considerandoli come valori senza segno e ponendo i 64 bit bassi
	del risultato nel registro speciale LO e i 64 bit alti del risultato nel registro speciale HI.

	\index{DSLL}
	\index{istruzioni!DSLL}
	\item \texttt{DSLL rd, rt, sa}\\
	Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di bit indicato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSLLV}
	\index{istruzioni!DSLLV}
	\item \texttt{DSLLV rd, rt, rs}\\
	Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro 
    rs che verr\`{a} letto come valore senza segno, e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSRA}
	\index{istruzioni!DSRA}
	\item \texttt{DSRA rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nel valore senza segno immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{DSRAV}
	\index{istruzioni!DSRAV}
	\item \texttt{DSRAV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro rs 
	 che verr\`{a} letto come valore senza segno,e pone il risultato in rd. 
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{DSRL}
	\index{istruzioni!DSRL}
	\item \texttt{DSRL rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.
	
	\index{DSRLV}
	\index{istruzioni!DSRLV}
	\item \texttt{DSRLV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSUB}
	\index{istruzioni!DSUB}
	\item \texttt{DSUB rd, rs, rt}\\
	Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit rs, considerandoli come valori con segno,
	e pone il risultato in rd. Lancia un eccezione in caso di overflow.

	\index{DSUBU}
	\index{istruzioni!DSUBU}
	\item \texttt{DSUBU rd, rs, rt}\\
	Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit rs, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{MFLO}
	\index{istruzioni!MFLO}
	\item \texttt{MFLO rd}\\
	Copia il contenuto del registro speciale LO in rd.

	\index{MFHI}
	\index{istruzioni!MFHI}
	\item \texttt{MFHI rd}\\
	Copia il contenuto del registro speciale HI in rd.

	\index{MOVN}
	\index{istruzioni!MOVN}
	\item \texttt{MOVN rd, rs, rt}\\
	Se rt \`{e} diverso da zero, copia il contenuto di rs in rd.
	
	\index{MOVZ}
	\index{istruzioni!MOVZ}
	\item \texttt{MOVZ rd, rs, rt}\\
	Se rt \`{e} uguale a zero, copia il contenuto di rs in rd.

	\index{MULT}
	\index{istruzioni!MULT}
	\item \texttt{MULT rs, rt}\\
	Esegue il prodotto tra i registri a 32-bit rs ed rt, ponendo i 32 bit bassi del risultato nel registro speciale LO
	e i 32 bit alti del risultato nel registro speciale HI.

	\index{MULTU}
	\index{istruzioni!MULTU}
	\item \texttt{MULTU rs, rt}\\
	Esegue il prodotto tra i registri a 32-bit rs ed rt, considerandoli come valori senza segno e ponendo i 32 bit 
	bassi del risultato nel registro speciale LO e i 32 bit alti del risultato nel registro speciale HI.
	
	\index{OR}
	\index{istruzioni!OR}
	\item \texttt{OR rd, rs, rt}\\
	Esegue un OR bit a bit tra rs ed rt, e pone il risultato in rd.

	\index{SLL}
	\index{istruzioni!SLL}
	\item \texttt{SLL rd, rt, sa}\\
	Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di bit indicati nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SLLV}
	\index{istruzioni!SLLV}
	\item \texttt{SLLV rd, rt, rs}\\
	Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SRA}
	\index{istruzioni!SRA}
	\item \texttt{SRA rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd.
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{SRAV}
	\index{istruzioni!SRAV}
	\item \texttt{SRAV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno,
	e pone il risultato nel registro a 32-bit in rd. 
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{SRL}
	\index{istruzioni!SRL}
	\item \texttt{SRL rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.
	
	\index{SRLV}
	\index{istruzioni!SRLV}
	\item \texttt{SRLV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 32-bit rt, del numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SUB}
	\index{istruzioni!SUB}
	\item \texttt{SUB rd, rs, rt}\\
	Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit rs, considerandoli come valori con segno,
	e pone il risultato in rd. Lancia un eccezione in caso di overflow.

	\index{SUBU}
	\index{istruzioni!SUBU}
	\item \texttt{SUBU rd, rs, rt}\\
	Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit rs, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{SLT}
	\index{istruzioni!SLT}
	\item \texttt{SLT rd, rs, rt}\\
	Pone il valore di rd ad 1 se il valore contenuto in rs \`{e} minore di quello contenuto in rt, 
	altrimenti pone rd a 0. Questa istruzione esegue un confronto con segno.

	\index{SLTU}
	\index{istruzioni!SLTU}
	\item \texttt{SLTU rd, rs, rt}\\
	Pone il valore di rd ad 1 se il valore contenuto in rs \`{e} minore di quello contenuto in rt, 
	altrimenti pone rd a 0. Questa istruzione esegue un confronto senza segno.

	\index{XOR}
	\index{istruzioni!XOR}
	\item \texttt{XOR rd, rs, rt}\\
	Esegue un OR esclusivo (XOR) bit a bit tra rs ed rt, e pone il risultato in rd.
\end{itemize}

Ecco la lista delle istruzioni ALU di tipo I.

\begin{itemize}
	\index{ADDI}
	\index{istruzioni!ADDI}
	\item \texttt{ADDI rt, rs, immediato}\\
	Effettua la somma tra il registro a 32 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Questa istruzione considera gli operandi come valori con segno.
	Lancia un eccezione in caso di overflow.

	\index{ADDIU}
	\index{istruzioni!ADDIU}
	\item \texttt{ADDIU rt, rs, immediato}\\
	Effettua la somma tra il registro a 32 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}
	
	\index{ANDI}
	\index{istruzioni!ANDI}
	\item \texttt{ANDI rt, rs, immediato}\\
	Esegue un AND bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

	\index{DADDI}
	\index{istruzioni!DADDI}
	\item \texttt{DADDI rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Questa istruzione considera gli operandi come valori con segno.
	Lancia un eccezione in caso di overflow.

	\index{DADDIU}
	\index{istruzioni!DADDIU}
	\item \texttt{DADDIU rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DADDUI}
	\index{istruzioni!DADDUI}
	\item \texttt{DADDUI rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}
    \WARN{}

	\index{LUI}
	\index{istruzioni!LUI}
	\item \texttt{LUI rt, immediato}\\
	Carica la costante definita dal valore immediato nella met\`{a} superiore dei 32
	bit inferiori di rt, effettuando l'estensione del segno sui 32 bit superiori del registro. 

	\index{ORI}
	\index{istruzioni!ORI}
	\item \texttt{ORI rt, rs, immediato}\\
	Effettua l'OR bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

	\index{SLTI}
	\index{istruzioni!SLTI}
	\item \texttt{SLTI rt, rs, immediato}\\
	Pone il valore di rt ad 1 se il valore di rs \`{e} minore di quello dell'immediato, 
	altrimenti pone rt a 0. Questa operazione effettua un confronto con segno.

	\index{SLTUI}
	\index{istruzioni!SLTUI}
	\item \texttt{SLTUI rt, rs, immediato}\\
	Pone il valore di rt ad 1 se il valore di rs \`{e} minore di quello dell'immediato, 
	altrimenti pone rt a 0. Questa operazione effettua un confronto senza segno.
	
	\index{XORI}
	\index{istruzioni!XORI}
	\item \texttt{XORI rt, rs, immediato}\\
	Effettua l'OR esclusivo bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

\end{itemize}

\section{Istruzioni Load/Store}
Questa categoria contiene tutte le istruzioni che effettuano trasferimenti di dati tra i registri 
e la memoria. Ognuna di esse \`{e} espressa nella forma:

\begin{center}
	\texttt{[etichetta:] \textbf{ISTRUZIONE} rt, offset(base)}
\end{center}

In base all'utilizzo di un'istruzione load oppure store, rt rappresenter\`{a} di volta in volta il registro 
sorgente o destinazione; offset \`{e} un'etichetta o un valore immediato e base \`{e} un registro. 
L'indirizzo \`{e} ottenuto sommando al valore del registro\texttt{base} il valore immediato di \texttt{offset}.

L'indirizzo specificato deve essere allineato in base al tipo di dato che si sta trattando. 
Le istruzioni di caricamento che terminano con ``U'' considerano il contenuto del registro rt 
come un valore senza segno.

Ecco la lista delle istruzioni di caricamento (LOAD):

\begin{itemize}
	\index{LB}
	\index{istruzioni!LB}
	\item \texttt{LB rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come byte con segno.

	\index{LBU}
	\index{istruzioni!LBU}
	\item \texttt{LBU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come byte senza segno.

	\index{LD}
	\index{istruzioni!LD}
	\item \texttt{LD rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una double word.

	\index{LH}
	\index{istruzioni!LH}
	\item \texttt{LH rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una half word con segno.

	\index{LHU}
	\index{istruzioni!LHU}
	\item \texttt{LHU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una half word senza segno.

	\index{LW}
	\index{istruzioni!LW}
	\item \texttt{LW rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una word con segno.
	
	\index{LWU}
	\index{istruzioni!LWU}
	\item \texttt{LWU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una word senza segno.
\end{itemize}

Ecco la lista delle istruzioni di memorizzazione (STORE):

\begin{itemize}
	\index{SB}
	\index{istruzioni!SB}
	\item \texttt{SB rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come un byte.
	
	\index{SD}
	\index{istruzioni!SD}
	\item \texttt{SD rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una double word.

	\index{SH}
	\index{istruzioni!SH}
	\item \texttt{SH rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una half word.

	\index{SW}
	\index{istruzioni!SW}
	\item \texttt{SW rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una word.
\end{itemize}

\section{Istruzioni di controllo del flusso}
Le istruzioni di controllo del flusso sono utilizzate per alterare l'ordine delle istruzioni prelevate 
dalla CPU nella fase di fetch. \`{E} possibile fare una distinzione tra tali istruzioni: tipo R, tipo I e tipo J.

\index{stalli!branch}
Tali istruzioni eseguono il salto alla fase di Instruction Decode (ID), ogni qual volta viene effettuato 
un fetch inutile. In tal caso, due istruzioni vengono rimosse dalla pipeline, ed il contatore degli stalli 
dovuti ai salti effettuati viene incrementato di due unit\'{a}.

Ecco la lista delle istruzioni di controllo del flusso di tipo R:
\begin{itemize}
	\index{JALR}
	\index{istruzioni!JALR}
	\item \texttt{JALR rs}\\
	Pone il contenuto di rs nel program counter, e salva in R31 l'indirizzo dell'istruzione che segue 
	l'istruzione JALR, che rappresenta il valore di ritorno.

	\index{JR}
	\index{istruzioni!JR}
	\item \texttt{JR rs}\\
	Pone il contenuto di rs nel program counter.
\end{itemize}

Ed ecco le istruzioni di controllo del flusso di tipo I:

\begin{itemize}
	\index{B}
	\index{instructions!B}
	\item \texttt{B offset}\\
	Salto incondizionato ad offset.

	\index{BEQ}
	\index{istruzioni!BEQ}
	\item \texttt{BEQ rs, rt, offset}\\
	Salta ad offset se rs \`{e} uguale ad rt.

	\index{BEQZ}
	\index{istruzioni!BEQZ}
	\item \texttt{BEQZ rs, offset}\\
	Salta ad offset se rs \`{e} uguale a zero.\\
	\WARN

	\index{BGEZ}
	\index{instructions!BGEZ}
	\item \texttt{BGEZ rs, offset}\\
	Effettua un salto relativo al PC ad offset se rs \`e maggiore di zero.

	\index{BNE}
	\index{istruzioni!BNE}
	\item \texttt{BNE rs, rt, offset}\\
	Salta ad offset se rs non \`{e} uguale ad rt.

	\index{BNEZ}
	\index{istruzioni!BNEZ}
	\item \texttt{BNEZ rs}\\
	Salta ad offset se rs non \`{e} uguale a zero.\\
	\WARN
\end{itemize}

Ecco la lista delle istruzioni di controllo del flusso di tipo J:

\begin{itemize}
	\index{J}
	\index{istruzioni!J}
	\item \texttt{J target}\\
	Pone il valore immediato nel program counter

	\index{JAL}
	\index{istruzioni!JAL}
	\item \texttt{JAL target}\\
	Pone il valore immediato nel program counter, e salva in R31 l'indirizzo 
	dell'istruzione che segue l'istruzione JAL, che rappresenta il valore di ritorno.
\end{itemize}

\section{L'istruzione \texttt{SYSCALL}}
\index{SYSCALL}
\label{sysc-man}
\index{istruzioni!SYSCALL}
\index{system calls}
L'istruzione \SC{} offre al programmatore un'interfaccia simile a quella offerta 
da un sistema operativo, rendendo disponibili sei differenti chiamate di sistema (system call).

Le system call richiedono che l'indirizzo dei loro parametri sia memorizzato nel registro R14, 
e pongono il loro valore di ritorno nel registro R1.
Tali system call sono il pi\`{u} possibile fedeli alla convenzione POSIX.

\index{system calls!exit()}
\subsection{\texttt{SYSCALL 0 - exit()}}
\SC{} 0 non richiede alcun parametro n\`{e} ritorna nulla, semplicemente ferma il simulatore.

\`{E} opportuno notare che se il simulatore non trova \SC{} 0 nel codice sorgente, 
o una qualsiasi istruzione equivalente (HALT  TRAP 0), terminer\`{a} automaticamente alla fine del sorgente.

\index{system calls!open()}
\subsection{\texttt{SYSCALL 1 - open()}}
\label{sys1}
\SC{} 1 richiede due parametri: una stringa (che termini con valore zero) che indica il percorso del file 
che deve essere aperto, ed una double word contenente un intero che indica i parametri che devono 
essere usati per specificare come aprire il file.

Tale intero pu\`{o} essere costruito sommando i parametri che si vogliono utilizzare, scelti dalla seguente lista:
\begin{itemize}
	\item \texttt{O\_RDONLY (0x01)} Apre il file in modalit\`{a} di sola lettura;
	\item \texttt{O\_WRONLY (0x02)} Apre il file in modalit\`{a} di sola scrittura;
	\item \texttt{O\_RDWR (0x03)} Apre il file in modalit\`{a} di lettura/scrittura;
	\item \texttt{O\_CREAT (0x04)} Crea il file se non esiste;
	\item \texttt{O\_APPEND (0x08)} In modalit\`{a} di scrittura, aggiunge il testo alla fine del file;
	\item \texttt{O\_TRUNC (0x08)} In modalit\`{a} di scrittura, cancella il contenuto del file al momento della sua apertura.
\end{itemize}

\`{E} obbligatorio specificare una delle prime tre modalit\`{a}. La quinta e la sesta sono esclusive, 
non \`{e} possibile specificare O\_APPEND se si specifica O\_TRUNC (e viceversa).Inoltre non si puo' specificare O\_CREAT 
se si specifica O\_RDONLY (oppure O\_RDWR).

\`{E} possibile specificare una combinazione di modalit\`{a} semplicemente sommando i valori interi ad esse associati. 
Ad esempio, se si vuole aprire un file in modalit\`{a} di sola scrittura ed aggiungere il testo alla fine del file, 
si dovr\`{a} specificare la modalit\`{a} $2 + 8 = 10$.

Il valore di ritorno delle chiamate di sistema \`{e} il nuovo descrittore del file (file descriptor) associato al file, 
che potr\`{a} essere utilizzato con le altre chiamate di sistema. Qualora si verifichi un errore, il valore di ritorno sar\`{a} -1.


\index{system calls!close()}
\subsection{\texttt{SYSCALL 2 - close()}}
\SC{} 2 richiede solo un parametro, il file descriptor del file che deve essere chiuso. 

 Qualora l'operazione termini con successo, \SC{} 2 ritorner\`{a} 0, altrimenti -1. 
 Possibili cause di errore sono il tentativo di chiudere un file inesistente, o di chiudere i file descriptor 0, 1 o 2, 
 che sono associati rispettivamente allo standard input, allo standard output ed allo standard error.

\index{system calls!read()}
\subsection{\texttt{SYSCALL 3 - read()}}
\SC{} 3 richiede tre parametri: il file descriptor da cui leggere, l'indirizzo nel quale i dati letti 
dovranno essere copiati, il numero di byte da leggere.

Se il primo parametro \`{e} 0, il simulatore permetter\`{a} all'utente di inserire un valore mediante un'apposita finestra di dialogo. 
Se la lunghezza del valore immesso \`{e} maggiore del numero di byte che devono essere letti, il simulatore mostrer\`{a} nuovamente la finestra.

La chiamata di sistema ritorna il numero di byte effettivamente letti, o -1 se l'operazione di lettura fallisce. Possibili cause di errore sono 
il tentativo di leggere da un file inesistente, o di leggere dai file descriptor 1 (standard output) o 2 (standard error), 
oppure il tentativo di leggere da un file di sola scrittura. 

\index{system calls!write()}
\subsection{\texttt{SYSCALL 4 - write()}}
\SC{} 4 richiede tre parametri: il file descriptor su cui scrivere, l'indirizzo dal quale i dati dovranno essere letti, il numero di byte da scrivere.

Se il primo parametro \`{e} 2 o 3, il simulatore mostrer\`{a} la finestra di input/output dove scriver\`{a} i dati letti.

Questa chiamata di sistema ritorna il numero di byte che sono stati scritti, o -1 se l'operazione di scrittura fallisce. 
Possibili cause di errore sono il tentativo di scrivere su un file inesistente, o sul file descriptor 0 (standard input), 
oppure il tentativo di scrivere su un file di sola lettura.

\index{system calls!printf()}
\label{sys5}
\subsection{\texttt{SYSCALL 5 - printf()}}
\SC{} 5 richiede un numero variabile di parametri, il primo \`{e} la cosiddetta
``format string'' o stringa di formato. Nella stringa di formato possono essere inseriti alcuni segnaposto,
descritti nella seguente lista:
\begin{itemize}
	\item \texttt{\%s} indica un parametro stringa;
	\item \texttt{\%i} indica un parametro intero;
	\item \texttt{\%d} si comporta come \texttt{\%i};
	\item \texttt{\%\%} indica \texttt{\%}
\end{itemize}

Per ciascuno dei segnaposto \texttt{\%s}, \texttt{\%d} o \texttt{\%i} la \SC{} 5
si aspetta un parametro, partendo dall'indirizzo del precedente.

Quando la \SC{} trova un segnaposto per un parametro intero, si aspetta che
il corrispondente parametro sia un valore intero, quando trova un segnaposto per un 
parametro stringa, si aspetta come parametro l'indirizzo della stringa stessa.

Il risultato  visualizzato nella finestra di input/output, ed il numero di byte scritti 
 posto in R1.

Qualora si verifichi un errore, R1 avr valore -1.

\section{Altre istruzioni}
In questa sezione sono descritte istruzioni che non rientrano nelle precedenti categorie.
\index{BREAK}
\index{istruzioni!BREAK}
\subsection{\texttt{BREAK}}
L'istruzione BREAK solleva un'eccezione che ha l'effetto di fermare l'esecuzione 
se il simulatore \`{e} in esecuzione. Pu\`{o} essere utilizzata per il debugging.

\index{NOP}
\index{istruzioni!NOP}
\subsection{\texttt{NOP}}
L'istruzione NOP non fa nulla, ed \`{e} utilizzata per creare pause nel codice sorgente.

\index{TRAP}
\index{istruzioni!TRAP}
\subsection{\texttt{TRAP}}
L'istruzione TRAP \`{e} deprecated, rappresenta un'alternativa all'istruzione \SC{}.

\index{HALT}
\index{istruzioni!HALT}
\subsection{\texttt{HALT}}
L'istruzione HALT \`{e} deprecated, rappresenta un'alternativa all'istruzione \SC{} 0, che ferma il simulatore.

\index{\EM{}!UI}
\index{\EM{}!GUI}
\chapter{L'interfaccia utente}
L'interfaccia grafica \EM{} \`{e} ispirata a quella di WinMIPS64. Infatti, la finestra principale \`{e} identica, 
eccetto che per qualche men\`{u}. 
% chapter~\ref{mips-simulators} for an overview of some MIPS and DLX simulators
% (including WinMIPS64), and to
%\cite{winmips-web} for more information about WinMIPS64.

%In figure~\ref{fig:edumips-main} you can see the main window of \EM{}, composed by
La finestra principale di \EM{} \`{e} caratterizzata da sei frame, che mostrano i differenti aspetti della simulazione. 
\`{E} inoltre presente una barra di stato, che ha il duplice scopo di mostrare il contenuto delle celle di memoria 
e dei registri quando vengono selezionati e di notificare all'utente che il simulatore \`{e} in esecuzione quando 
la simulazione \`{e} stata avviata ma la modalit\`{a} verbose  non \`{e} stata attivata. 
Maggiori dettagli sono descritti nelle sezioni a seguire.

\index{\EM{}!menu}
\section{La barra del men\`{u}}
La barra del men\`{u} contiene sei opzioni:

\index{\EM{}!menu!File}
\subsection{File}
Il men\`{u} File contiene comandi per l'apertura dei file, per resettare o fermare il simulatore e per scrivere i trace file.
\begin{itemize}
	\item \textbf{Apri...} Apre una finestra che consente all'utente di scegliere un file sorgente da aprire.
	\item \textbf{Apri recente} Mostra la lista dei file recentemente aperti dal simulatore, dalla quale l'utente pu\`{o} scegliere il file da aprire.
	\item \textbf{Resetta} Inizializza nuovamente il simulatore, mantenendo aperto il file che era stato caricato ma facendone ripartire l'esecuzione.
	\item \textbf{Scrivi Tracefile Dinero...} Scrive i dati di accesso alla memoria in un file, nel formato xdin.
	\item \textbf{Esci} Chiude il simulatore.
\end{itemize}
La voce del men\`{u} \textbf{Scrivi Tracefile Dinero...} \`{e} disponibile solo quando un file sorgente \`{e} 
stato completamente eseguito ed \`{e} stata gi\`{a} raggiunta la fine dell'esecuzione.


\index{\EM{}!menu!Esegui}
\subsection{Esegui}
Il menu Esegui contiene voci riguardanti il flusso di esecuzione della simulazione.
\begin{itemize}
	\item \textbf{Ciclo singolo} Esegue un singolo passo di simulazione.
	\item \textbf{Completa} Inizia l'esecuzione, fermandosi quando il simulatore raggiunge una \SC{} 0 (o equivalente) o
	un'istruzione di \texttt{BREAK}, oppure quando l'utente seleziona la voce Stop del men\`{u} (o preme F9).  
	\item \textbf{Cicli multipli} Esegue un certo numero di passi di
    simulazione, tale valore pu\`o essere configurato 
	attraverso la finestra di configurazione. Vedere la sezione~\ref{dialog-settings} per ulteriori dettagli.
	\item \textbf{Ferma} Ferma l'esecuzione quando il simulatore \`{e} in
    modalit\`{a} ``Completa'' o ``Cicli multipli'', come descritto precedentemente.
\end{itemize}
Il menu \`{e} disponibile solo quando \`{e} stato caricato un file sorgente e non \`{e} ancora stato raggiunto il termine della simulazione.
La voce \textbf{Stop} del men\`{u}  disponibile solo in modalit\`{a} ``Completa'' o ``Cicli multipli'' mode.

\index{\EM{}!menu!Configura}
\subsection{Configura}
Il menu Configura fornisce l'opportunit\`a di personalizzare l'aspetto ed il funzionamento di \EM{}.
\begin{itemize}
	\item \textbf{Impostazioni...} Apre la finestra di configurazione, descritta nella sezione~\ref{dialog-settings}
	\item \textbf{Selezione lingua} Consente di modificare la lingua usata dall'interfaccia utente. Attualmente sono 
	supportate solo inglese ed italiano. Questa modifica riguarda ogni aspetto dell'interfaccia grafica, 
	dal titolo delle finestre al manuale in linea ed i messaggi di errore o le notifiche.
\end{itemize}
The \texttt{Impostazioni...} non \`{e} disponibile quando il simulatore \`{e} in modalit\`{a} ``Completa'' o ``Cicli multipli'', a causa di possibili race conditions.

\index{\EM{}!menu!Strumenti}
\subsection{Strumenti}
Questo men\`{u} contiene solo una voce, utilizzata per aprire la finestra del Dinero frontend.
\begin{itemize}
	\item \textbf{Dinero Frontend...} Apre la finestra del Dinero Frontend. Vedi paragrafo~\ref{dialog-dinero}.
\end{itemize}
Questo men\`{u} non \`{e} disponibile finch\`{e} non \`{e} stata portata a termine l'esecuzione del programma

\index{\EM{}!menu!Finestra}
\subsection{Finestra}
Questo men\`{u} contiene voci relative alle operazioni con le finestre.
\begin{itemize}
	\item \textbf{Tile} Ordina le finestre visibili in modo tale che non vi siano pi\`{u} di tre finestre in una riga, 
	tentando di massimizzare lo spazio occupato da ciascuna finestra.
\end{itemize}
Le altre voci del men\`{u} modificano semplicemente lo stato di ciascuna finestra, rendendola visibile o riducendola ad icona.

\index{\EM{}!menu!Aiuto}
\subsection{Aiuto}
Questo men\`{u} contiene voci relative all'aiuto in linea.
\begin{itemize}
	\item \textbf{Manuale...} Mostra la finestra di help. Vedi~\ref{dialog-help}
	\item \textbf{Informazioni su...} Mostra una finestra contenente i nomi di coloro che hanno collaborato al progetto, 
	insieme ad i loro ruoli.
\end{itemize}

\index{\EM{}!Finestre}
\section{Finestre}
L'interfaccia grafica \`{e} composta da sette finestre, sei delle quali sono visibili per default, mentre una (la finestra di I/O) \`{e} nascosta.
\index{\EM{}!finestre!Cicli}
\subsection{Cicli}
La finestra Cicli mostra l'evoluzione del flusso di esecuzione nel tempo, visualizzando in ogni istante 
quali istruzioni sono nella pipeline, ed in quale stadio si trovano.
\index{\EM{}!finestre!Registri}
\subsection{Registri}
La finestra Registri mostra il contenuto di ciascun registro. Mediante un click col tasto sinistro del mouse 
\`{e} possibile vedere il loro valore decimale (con segno) nella barra di stato, mentre con un doppio click verr\`{a} 
aperta una finestra di dialogo che consentir\`{a} all'utente di cambiare il valore del registro

\index{\EM{}!finestre!Statistiche}
\subsection{Statistiche}
La finestra Statistiche mostra alcune statistiche riguardanti l'esecuzione del programma.

\index{\EM{}!finestre!Pipeline}
\subsection{Pipeline}
La finestra Pipeline mostra lo stato attuale della pipeline, visualizzando ciascuna istruzione con il suo stadio. 
I differenti colori evidenziano i vari stadi della pipeline stessa.

\index{\EM{}!finestre!Memoria}
\subsection{Memoria}
La finestra Memoria mostra il contenuto delle celle di memoria, insieme alle etichette ed i commenti, 
tratti dal codice sorgente. Il contenuto delle celle di memoria, come per i registri, pu\`{o} essere modificato 
con un doppio click, e mediante un singolo click del mouse verr\`{a} mostrato il loro valore decimale nella barra di stato. 
La prima colonna mostra l'indirizzo esadecimale della cella di memoria, e la seconda il valore della cella stessa. 
Le altre colonne mostrano invece informazioni addizionali provenienti dal codice sorgente.

\index{\EM{}!finestre!Codice}
\subsection{Codice}
La finestra Codice visualizza le istruzioni caricate in memoria.. La prima colonna mostra l'indirizzo dell'istruzione, 
mentre la seconda mostra la rappresentazione esadecimale dell'istruzione stessa. Le altre colonne mostrano infine 
informazioni addizionali provenienti dal codice sorgente.

\index{\EM{}!finestre!Input/Output}
\subsection{Input/Output}
La finestra Input/Output fornisce un'interfaccia all'utente per la visualizzazione dell'output creato dai programmi 
mediante le \SC{} 4 e 5. Attualmente non \`{e} utilizzata per l'input di dati, ed al suo posto viene utilizzata una 
finestra di dialogo che viene mostrata quando una \SC{} 3  tenta di leggere dallo standard input, 
ma future versioni includeranno una casella di testo per l'input.

\index{\EM{}!finestre di dialogo}
\section{Finestre di dialogo}
Le finestre di dialogo sono utilizzate da EduMIPS64 per interagire con l'utente
in vari modi. Ecco un riassunto delle pi\`u importanti:

\index{\EM{}!finestre di dialogo!Impostazioni}
\subsection{Impostazioni}
\label{dialog-settings}
Nella finestra di configurazione possono essere configurati vari aspetti del simulatore.

La sezione ``Impostazioni generali'' consente di configurare il forwarding ed il numero di passi da effettuare nella modalit\`{a} Cicli multipli.

La sezione ``Comportamento'' permette di abilitare o disabilitare gli avvisi durante la fase di parsing, 
l'opzione ``sincronizza la GUI con la CPU nell'esecuzione multi step'', quando abilitata, sincronizzer\`{a}
lo stato grafico delle finestre con lo stato interno del simulatore. Ci\`{o} implicher\`{a} una simulazione pi\`{u} lenta, 
ma con la possibilit\`{a} di avere un resoconto grafico esplicito di ci\`{o} che sta avvenendo durante la simulazione. 
L'opzione ``intervallo tra i cicli'', qualora sia abilitata, influenzer\`{a} il numero di millisecondi che il simulatore dovr\`{a} 
attendere prima di cominciare un nuovo ciclo. Tali opzioni hanno effetto solo quando la simulazione \`{e} avviata 
utilizzando le opzioni ``Completa'' o ``Cicli multipli'' dal menu Esegui.

Le ultime due opzioni stabiliscono il comportamento del simulatore quando si verifica un'eccezione sincrona. 
\`{E} importante notare che se le eccezioni sincrone sono mascherate, non succeder\`{a} nulla, anche se l'opzione 
``Termina se si verifica un'eccezione sincrona'' \`{e} abilitata. Se le eccezioni non sono mascherate e tale opzione \`{e} abilitata, apparir\`{a} una finestra di dialogo, 
e la simulazione sar\`{a} fermata non appena tale finestra verr\`{a} chiusa.

L'ultima sezione permette di modificare i colori associati ai diversi stadi della pipeline. Abbastanza inutile, ma carino.

\index{\EM{}!finestre di dialogo!Dinero Frontend}
\subsection{Dinero Frontend}
\label{dialog-dinero}
La finestra di dialogo Dinero Frontend consente di avviare un processo DineroIV con il trace file 
generato internamente mediante l'esecuzione del programma. Nella prima casella di testo c'\`{e} il percorso 
dell'eseguibile DineroIV, e nella seconda devono essere inseriti i parametri opportuni.

% Please see~\cite{dinero-web} for further informations about the DineroIV cache simulator.

La sezione pi\`{u} in basso contiene l'output del processo DineroIV, dal quale \`{e} possibile prelevare i dati di cui si necessita.

\index{\EM{}!finestre di dialogo!Aiuto}
\subsection{Aiuto}
\label{dialog-help}
La finestra di Aiuto contiene tre sezioni con qualche indicazione riguardo l'utilizzo del simulatore. 
La prima \`{e} una breve introduzione ad EduMIPS64, la seconda contiene informazioni riguardanti 
l'interfaccia grafica e la terza contiene un riassunto delle istruzioni supportate.

\index{\EM{}!Opzioni da linea di comando}
\section{Opzioni da linea di comando}
Sono disponibili tre opzioni da linea di comando. Esse sono descritte di seguito, con il nome per esteso scritto tra parentesi. 
Nomi abbreviati e per esteso possono essere utilizzati indifferentemente.
\begin{itemize}
	\item \texttt{-h (--help)} mostra un messaggio di aiuto contenente la versione del simulatore ed un breve riassunto delle opzioni da linea di comando.
	\item \texttt{-f (--file) filename} Apre \texttt{filename} nel simulatore.
	\item \texttt{-d (--debug)} Accede alla modalit\`{a} di debugging.
\end{itemize}

L'opzione \texttt{--debug} ha l'effetto di attivare la modalit\`{a} di debugging. 
In tale modalit\`a \`{e} disponibile una nuova finestra, la finestra Debug, che mostra il resoconto delle 
attivit\`{a} interne di  \EM{}. Tale finestra non \`{e} utile per l'utente finale, \`{e} stata infatti ideata per poter essere utilizzata 
dagli sviluppatori di \EM{}.

\index{\EM{}!esecuzione}
\section{Eseguire \EM{}}
Il file \texttt{.jar} di \EM{} pu\`{o} funzionare sia come file .jar eseguibile che come applet, 
quindi pu\`{o} essere eseguito in entrambi i modi, che richiedono il Java Runtime Environment, versione 5 o successiva.

Per eseguire il file come applicazione a s\`{e} stante, l'eseguibile \texttt{java} deve essere avviato nel seguente modo: 
\texttt{java -jar edumips64-version.jar}, dove la stringa
\texttt{version} deve essere sostituita con la versione attuale del simulatore. 
Su alcuni sistemi, potrebbe essere possibile eseguire il programma semplicemente con un click sul file \texttt{.jar}.

Per eseguire il file come applet deve essere utilizzato il tag \texttt{<applet>}. Il sito web di \EM{}
presenta una pagina gi\`{a} contenente l'applet, in modo tale che chiunque possa eseguire il programma senza il problema dell'utilizzo da linea di comando.

%\cite{edumips-web} contains a page that already contains the applet, so
%that everyone can execute it without the hassle of using the command line.
\printindex

\chapter{Listati di esempio}
Qui di seguito sono elencati degli esempi utili per comprendere il funzionamento
delle istruzioni che accetta \EM{} (versione \EV)

\section{\SC{}}
Per informazioni dettagliate riguardo l'utilizzo delle \SC{} consultare la
sezione \ref{sysc-man}. Di seguito si trovano degli esempi pratici per utilizzare tutte e 6 le \SC{}.

\subsection{Esempio sulle \SC{}}
Ecco un esempio di programmma che apre un file, ne legge i primi 16 byte, 
li scrive in append sullo stesso file (che poi chiude) ed infine stampa un messaggio di conferma:\\
\lstinputlisting[caption={Esempio \SC{}}, label={code:syscall_all}, style={mips}] {listings/syscall_all.s}

La sezione '.data' comincia con l'inserimento in memoria di 5 messaggi che serviranno per far sapere
all'utilizzatore l'esito delle operazioni effettuate.L'etichetta 'value'  \'{e} quella dove verranno salvati i dati letti,
dati che verranno prelevati per essere successivamente scritti sul file.
 Di seguito troviamo l'elenco dei parametri necessari per la chiamata delle \SC{}. \\Per quanto riguarda la \SC{} 1 
bisogna salvare in memoria per prima cosa il path del file da aprire, e nella locazione di memoria immediatamente
 successiva (quindi nella riga successiva) un intero che rappresenta la modalit\`{a} d'apertura (per maggiori informazioni 
riguardo alle modalit\`{a} d'apertura rimandiamo alla sezione \ref{sys1}).\\ La \SC{} 2 invece richiede un solo parametro, 
il file descriptor del file da chiudere.\\ Le \SC{} 3 e 4 necessitano dello stesso numero di parametri (tre), il primo  \'{e}  il file descriptor
del file da cui leggere(per la \SC{} 3) o scrivere (per la \SC{} 4), il secondo \'{e} l'indirizzo di memoria da cui 
leggere (o scrivere) i byte, e il terzo \'{e} un'intero che rappresenta il numero di byte da leggere (o scrivere).
\\Infine la \SC{} 5 accetta in ingresso un numero variabile di parametri; il primo \'{e} sempre necessario, ed \'{e}
 la cosiddetta format string, cio\`{e} la striga da inviare allo standard output. A seconda del tipo di format string
 pu\`{o} essere necessario salvare un numero arbitrario di altri parametri (per maggiori informazioni consultare 
la sezione \ref{sys5} o l'esempio \ref{code:printf}).\\

Passiamo ora alla sezione '.text'.Essa comincia con le operazioni necessarie per l'apertura del file, cio\`{e} 
l'inserimento dell'indirizzo di memoria dell'etichetta 'params\_sys1' nel registro r14 (riga 26). Ora si pu\`{o} chiamare la \SC{} 1,
salvare il file descriptor del file letto in modo da poterlo riutilizzare (riga 29), e 
 controllare poi che il valore di ritorno della \SC{} (contenuto in r1) sia diverso da $-1$ , nel qual caso si passa all' etichetta 
'read'(riga 30).Se invece il valore dovesse essere $-1$ si passa all'etichetta 'end', facendo in modo da salvare in r4 l'indirizzo di memoria 
del messaggio di errore appropriato (righe 31, 32).\\

Il listato continua con il salvataggio nel registro r14 dell'indirizzo di memoria dell'etichetta 'params\_sys3', dove viene poi 
inserito (riga 35) il file descriptor del file da cui leggere precedentemente salvato. Allo stesso modo salviamo nell'apposta
zona di memoria l'indirizzo in cui salvare i byte letti (righe 36-37) e poi chiamiamo la \SC{} 3. Come fatto precedentemente  
controlliamo che il valore di ritorno della \SC{} (contenuto in r1) sia diverso da $-1$ , nel qual caso si passa all' etichetta 
'write'(riga 39).Se invece il valore dovesse essere $-1$ si passa all'etichetta 'end', facendo in modo da salvare in r4 l'indirizzo di memoria 
del messaggio di errore appropriato (righe 40, 41).\\

La parte relativa alla \SC{} 4 \'{e} molto simile a quella della \SC{} 3. Infatti anche qui salviamo in memoria l'indirizzo iniziale dei
parametri richiesti (riga 43) e poi  inseriamo lì il file descriptor del file su cui scrivere (riga 44), e nella locazione di memoria immediatamente
successiva mettiamo l'indirizzo (anch'esso di memoria) da cui prelevare i byte da scrivere (in questo caso lo stesso indirizzo in cui sono stati
depositati i byte appena letti dalla \SC{} 3). Ora controlliamo che il valore di ritorno della \SC{} (contenuto in r1) sia diverso da $-1$ , 
nel qual caso si passa all' etichetta 'close'(riga 48).Se invece il valore dovesse essere $-1$ si passa all'etichetta 'end', facendo in modo da salvare
 in r4 l'indirizzo di memoria del messaggio di errore appropriato (righe 49, 50).\\

A questo punto bisogna chiudere il file, tramite la \SC{} 4, che accetta come unico parametro il file descriptor da chiudere. Dopo aver controllato 
ancora una volta l'assenza di errori (righe 55, 56, 57) passiamo all'etichetta 'end'.\\

Quest' ultima contiene le operazioni da effettuare prima di invocare la \SC{} 5. Tali operazioni consitono nel salvare in r14 l'indirizzo di 
'params\_sys5' , e in 'params\_sys5' l'indirizzo della format string. Eventuali paramtri aggiuntivi saranno prelevati
dalle locazioni di memoria immediatamente successive. Come si pu\`{o} notare la 'format string' nel nostro caso  \'{e} molto semplice, e non
 richiede parametri aggiuntivi; per un esempio pi\`{u} esaustivo da questo punto di vista consultare l'esempio \ref{code:printf} .


\subsection{Un esempio pi\`u complesso di \SC{} 5}
La \SC{} 5 utilizza un meccanismo un po' complesso per il passaggio dei
parametri, che verr\`a chiarito con il seguente esempio:
\lstinputlisting[caption={Esempio non banale di \SC{} 5}, label={code:printf}, style={mips}] {listings/test-printf.s}

L'indirizzo della stringa di formato viene inserito nel registro R5, il cui
contenuto viene salvato in memoria all'indirizzo fs\_addr. Agli indirizzi
s1\_addr ed s2\_addr vengono salvati gli indirizzi dei parametri di tipo stringa
corrispondenti ai due segnaposto \%s nella stringa di formato.

Guardando la memoria, \`e chiaro che subito dopo l'indirizzo della stringa di
formato sono presenti i parametri corrispondenti ai segnaposto: ai parametri di
tipo intero corrispondono dei dati di tipo intero, mentre ai parametri di tipo
stringa corrispondono invece degli indirizzi. Infatti, in queste due locazioni
di memoria (s1\_addr ed s2\_addr) abbiamo inserito gli indirizzi delle due
stringhe che vogliamo stampare su standard output in corrispondenza dei
segnaposto \%s.

L'esecuzione dell'esempio mostrer\`a come la \SC{} 5 sia in grado di gestire
stringhe di formato complesse come quella presente all'indirizzo format\_str.
\end{document}
